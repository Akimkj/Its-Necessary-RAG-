[
  {
    "id": 1,
    "question": "What does the \"yield\" keyword do in Python?",
    "answer": "To understand what yield does, you must understand what generators are. And before you can understand generators, you must understand iterables. Iterables When you create a list, you can read its items one by one. Reading its items one by one is called iteration: >>> mylist = [1, 2, 3] >>> for i in mylist: ... print(i) 1 2 3 mylist is an iterable. When you use a list comprehension, you create a list, and so an iterable: >>> mylist = [x*x for x in range(3)] >>> for i in mylist: ... print(i) 0 1 4 Everything you can use \"for... in...\" on is an iterable; lists, strings, files... These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values. Generators Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory, they generate the values on the fly: >>> mygenerator = (x*x for x in range(3)) >>> for i in mygenerator: ... print(i) 0 1 4 It is just the same except you used () instead of []. BUT, you cannot perform for i in mygenerator a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end after calculating 4, one by one. Yield yield is a keyword that is used like return, except the function will return a generator. >>> def create_generator(): ... mylist = range(3) ... for i in mylist: ... yield i*i ... >>> mygenerator = create_generator() # create a generator >>> print(mygenerator) # mygenerator is an object! >>> for i in mygenerator: ... print(i) 0 1 4 Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once. To master yield, you must understand that when you call the function, the code you have written in the function body does not run. The function only returns the generator object, this is a bit tricky. Then, your code will continue from where it left off each time for uses the generator. Now the hard part: The first time the for calls the generator object created from your function, it will run the code in your function from the beginning until it hits yield, then it'll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting yield. That can be because the loop has come to an end, or because you no longer satisfy an \"if/else\". Your code explained Generator: # Here you create the method of the node object that will return the generator def _get_child_candidates(self, distance, min_dist, max_dist): # Here is the code that will be called each time you use the generator object: # If there is still a child of the node object on its left # AND if the distance is ok, return the next child if self._leftchild and distance - max_dist = self._median: yield self._rightchild # If the function arrives here, the generator will be considered empty # There are no more than two values: the left and the right children Caller: # Create an empty list and a list with the current object reference result, candidates = list(), [self] # Loop on candidates (they contain only one element at the beginning) while candidates: # Get the last candidate and remove it from the list node = candidates.pop() # Get the distance between obj and the candidate distance = node._get_dist(obj) # If the distance is ok, then you can fill in the result if distance = min_dist: result.extend(node._values) # Add the children of the candidate to the candidate's list # so the loop will keep running until it has looked # at all the children of the children of the children, etc. of the candidate candidates.extend(node._get_child_candidates(distance, min_dist, max_dist)) return result This code contains several smart parts: • The loop iterates on a list, but the list expands while the loop is being iterated. It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, candidates.extend(node._get_child_candidates(distance, min_dist, max_dist)) exhausts all the values of the generator, but while keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node. • The extend() method is a list object method that expects an iterable and adds its values to the list. Usually, we pass a list to it: >>> a = [1, 2] >>> b = [3, 4] >>> a.extend(b) >>> print(a) [1, 2, 3, 4] But in your code, it gets a generator, which is good because: • You don't need to read the values twice. • You may have a lot of children and you don't want them all stored in memory. And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples, and generators! This is called duck typing and is one of the reasons why Python is so cool. But this is another story, for another question... You can stop here, or read a little bit to see an advanced use of a generator: Controlling a generator exhaustion >>> class Bank(): # Let's create a bank, building ATMs ... crisis = False ... def create_atm(self): ... while not self.crisis: ... yield \"$100\" >>> hsbc = Bank() # When everything's ok the ATM gives you as much as you want >>> corner_street_atm = hsbc.create_atm() >>> print(corner_street_atm.next()) $100 >>> print(corner_street_atm.next()) $100 >>> print([corner_street_atm.next() for cash in range(5)]) ['$100', '$100', '$100', '$100', '$100'] >>> hsbc.crisis = True # Crisis is coming, no more money! >>> print(corner_street_atm.next()) >>> wall_street_atm = hsbc.create_atm() # It's even true for new ATMs >>> print(wall_street_atm.next()) >>> hsbc.crisis = False # The trouble is, even post-crisis the ATM remains empty >>> print(corner_street_atm.next()) >>> brand_new_atm = hsbc.create_atm() # Build a new one to get back in business >>> for cash in brand_new_atm: ... print cash $100 $100 $100 $100 $100 $100 $100 $100 $100 ... Note: For Python 3, useprint(corner_street_atm.__next__()) or print(next(corner_street_atm)) It can be useful for various things like controlling access to a resource. Itertools, your best friend The itertools module contains special functions to manipulate iterables. Ever wish to duplicate a generator? Chain two generators? Group values in a nested list with a one-liner? Map / Zip without creating another list? Then just import itertools. An example? Let's see the possible orders of arrival for a four-horse race: >>> horses = [1, 2, 3, 4] >>> races = itertools.permutations(horses) >>> print(races) >>> print(list(itertools.permutations(horses))) [(1, 2, 3, 4), (1, 2, 4, 3), (1, 3, 2, 4), (1, 3, 4, 2), (1, 4, 2, 3), (1, 4, 3, 2), (2, 1, 3, 4), (2, 1, 4, 3), (2, 3, 1, 4), (2, 3, 4, 1), (2, 4, 1, 3), (2, 4, 3, 1), (3, 1, 2, 4), (3, 1, 4, 2), (3, 2, 1, 4), (3, 2, 4, 1), (3, 4, 1, 2), (3, 4, 2, 1), (4, 1, 2, 3), (4, 1, 3, 2), (4, 2, 1, 3), (4, 2, 3, 1), (4, 3, 1, 2), (4, 3, 2, 1)] Understanding the inner mechanisms of iteration Iteration is a process implying iterables (implementing the __iter__() method) and iterators (implementing the __next__() method). Iterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables. There is more about it in this article about how for loops work."
  },
  {
    "id": 2,
    "question": "What does if __name__ == \"__main__\": do?",
    "answer": "Short Answer It's boilerplate code that protects users from accidentally invoking the script when they didn't intend to. Here are some common problems when the guard is omitted from a script: • If you import the guardless script in another script (e.g. import my_script_without_a_name_eq_main_guard), then the latter script will trigger the former to run at import time and using the second script's command line arguments. This is almost always a mistake. • If you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet. Long Answer To better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism. Whenever the Python interpreter reads a source file, it does two things: • it sets a few special variables like __name__, and then • it executes all of the code found in the file. Let's see how this works and how it relates to your question about the __name__ checks we always see in Python scripts. Code Sample Let's use a slightly different code sample to explore how imports and scripts work. Suppose the following is in a file called foo.py. # Suppose this is foo.py. print(\"before import\") import math print(\"before function_a\") def function_a(): print(\"Function A\") print(\"before function_b\") def function_b(): print(\"Function B {}\".format(math.sqrt(100))) print(\"before __name__ guard\") if __name__ == '__main__': function_a() function_b() print(\"after __name__ guard\") Special Variables When the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the __name__ variable. When Your Module Is the Main Program If you are running your module (the source file) as the main program, e.g. python foo.py the interpreter will assign the hard-coded string \"__main__\" to the __name__ variable, i.e. # It's as if the interpreter inserts this at the top # of your module when run as the main program. __name__ = \"__main__\" When Your Module Is Imported By Another On the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports: # Suppose this is in some other main program. import foo The interpreter will search for your foo.py file (along with searching for a few other variants), and prior to executing that module, it will assign the name \"foo\" from the import statement to the __name__ variable, i.e. # It's as if the interpreter inserts this at the top # of your module when it's imported from another module. __name__ = \"foo\" Executing the Module's Code After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation. Always • It prints the string \"before import\" (without quotes). • It loads the math module and assigns it to a variable called math. This is equivalent to replacing import math with the following (note that __import__ is a low-level function in Python that takes a string and triggers the actual import): # Find and load a module given its string name, \"math\", # then assign it to a local variable called math. math = __import__(\"math\") • It prints the string \"before function_a\". • It executes the def block, creating a function object, then assigning that function object to a variable called function_a. • It prints the string \"before function_b\". • It executes the second def block, creating another function object, then assigning it to a variable called function_b. • It prints the string \"before __name__ guard\". Only When Your Module Is the Main Program • If your module is the main program, then it will see that __name__ was indeed set to \"__main__\" and it calls the two functions, printing the strings \"Function A\" and \"Function B 10.0\". Only When Your Module Is Imported by Another • (instead) If your module is not the main program but was imported by another one, then __name__ will be \"foo\", not \"__main__\", and it'll skip the body of the if statement. Always • It will print the string \"after __name__ guard\" in both situations. Summary In summary, here's what'd be printed in the two cases: # What gets printed if foo is the main program before import before function_a before function_b before __name__ guard Function A Function B 10.0 after __name__ guard # What gets printed if foo is imported as a regular module before import before function_a before function_b before __name__ guard after __name__ guard Why Does It Work This Way? You might naturally wonder why anybody would want this. Well, sometimes you want to write a .py file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself. Examples: • Your module is a library, but you want to have a script mode where it runs some unit tests or a demo. • Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing .py files like your script and running special test functions. You don't want it to try running the script just because it's importing the module. • Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users. Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. \"Running\" the script is a side effect of importing the script's module. Food for Thought • Question: Can I have multiple __name__ checking blocks? Answer: it's strange to do so, but the language won't stop you. • Suppose the following is in foo2.py. What happens if you say python foo2.py on the command-line? Why? # Suppose this is foo2.py. import os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters def function_a(): print(\"a1\") from foo2 import function_b print(\"a2\") function_b() print(\"a3\") def function_b(): print(\"b\") print(\"t1\") if __name__ == \"__main__\": print(\"m1\") function_a() print(\"m2\") print(\"t2\") • Now, figure out what will happen in foo3.py (having removed the __name__ check): # Suppose this is foo3.py. import os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters def function_a(): print(\"a1\") from foo3 import function_b print(\"a2\") function_b() print(\"a3\") def function_b(): print(\"b\") print(\"t1\") print(\"m1\") function_a() print(\"m2\") print(\"t2\") • What will this do when used as a script? When imported as a module? # Suppose this is in foo4.py __name__ = \"__main__\" def bar(): print(\"bar\") print(\"before __name__ guard\") if __name__ == \"__main__\": bar() print(\"after __name__ guard\")"
  },
  {
    "id": 3,
    "question": "Does Python have a ternary conditional operator?",
    "answer": "Yes, it was added in version 2.5. The expression syntax is: a if condition else b First condition is evaluated, then exactly one of either a or b is evaluated and returned based on the Boolean value of condition. If condition evaluates to True, then a is evaluated and returned but b is ignored, or else when b is evaluated and returned but a is ignored. This allows short-circuiting because when condition is true only a is evaluated and b is not evaluated at all, but when condition is false only b is evaluated and a is not evaluated at all. For example: >>> 'true' if True else 'false' 'true' >>> 'true' if False else 'false' 'false' Note that conditionals are an expression, not a statement. This means you can't use statements such as pass, or assignments with = (or \"augmented\" assignments like +=), within a conditional expression: >>> pass if False else pass File \"\", line 1 pass if False else pass ^ SyntaxError: invalid syntax >>> # Python parses this as `x = (1 if False else y) = 2` >>> # The `(1 if False else x)` part is actually valid, but >>> # it can't be on the left-hand side of `=`. >>> x = 1 if False else y = 2 File \"\", line 1 SyntaxError: cannot assign to conditional expression >>> # If we parenthesize it instead... >>> (x = 1) if False else (y = 2) File \"\", line 1 (x = 1) if False else (y = 2) ^ SyntaxError: invalid syntax (In 3.8 and above, the := \"walrus\" operator allows simple assignment of values as an expression, which is then compatible with this syntax. But please don't write code like that; it will quickly become very difficult to understand.) Similarly, because it is an expression, the else part is mandatory: # Invalid syntax: we didn't specify what the value should be if the # condition isn't met. It doesn't matter if we can verify that # ahead of time. a if True You can, however, use conditional expressions to assign a variable like so: x = a if True else b Or for example to return a value: # Of course we should just use the standard library `max`; # this is just for demonstration purposes. def my_max(a, b): return a if a > b else b Think of the conditional expression as switching between two values. We can use it when we are in a 'one value or another' situation, where we will do the same thing with the result, regardless of whether the condition is met. We use the expression to compute the value, and then do something with it. If you need to do something different depending on the condition, then use a normal if statement instead. Keep in mind that it's frowned upon by some Pythonistas for several reasons: • The order of the arguments is different from those of the classic condition ? a : b ternary operator from many other languages (such as C, C++, Go, Perl, Ruby, Java, JavaScript, etc.), which may lead to bugs when people unfamiliar with Python's \"surprising\" behaviour use it (they may reverse the argument order). • Some find it \"unwieldy\", since it goes contrary to the normal flow of thought (thinking of the condition first and then the effects). • Stylistic reasons. (Although the 'inline if' can be really useful, and make your script more concise, it really does complicate your code) If you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, x = 4 if b > 8 else 9 is read aloud as x will be 4 if b is greater than 8 otherwise 9. Official documentation: • Conditional expressions • Is there an equivalent of C’s ”?:” ternary operator?"
  },
  {
    "id": 4,
    "question": "What are metaclasses in Python?",
    "answer": "Classes are objects Before delving into metaclasses, a solid grasp of Python classes is beneficial. Python holds a particularly distinctive concept of classes, a notion it adopts from the Smalltalk language. In most languages, classes are descriptions of how to create an object. That is somewhat true in Python too: >>> class ObjectCreator(object): ... pass >>> my_object = ObjectCreator() >>> print(my_object) But classes are more than that in Python. Classes are objects too. Yes, objects. When a Python script runs, every line of code is executed from top to bottom. When the Python interpreter encounters the class keyword, Python creates an object out of the \"description\" of the class that follows. Thus, the following instruction >>> class ObjectCreator(object): ... pass ...creates an object with the name ObjectCreator! This object (the class) is itself capable of creating objects (called instances). But still, it's an object. Therefore, like all objects: • you can assign it to a variable1 JustAnotherVariable = ObjectCreator • you can attach attributes to it ObjectCreator.class_attribute = 'foo' • you can pass it as a function parameter print(ObjectCreator) 1 Note that merely assigning it to another variable doesn't change the class's __name__, i.e., >>> print(JustAnotherVariable) >>> print(JustAnotherVariable()) Creating classes dynamically Since classes are objects, you can create them on the fly, like any object. First, you can create a class in a function using class: >>> def choose_class(name): ... if name == 'foo': ... class Foo(object): ... pass ... return Foo # return the class, not an instance ... else: ... class Bar(object): ... pass ... return Bar >>> MyClass = choose_class('foo') >>> print(MyClass) # the function returns a class, not an instance >>> print(MyClass()) # you can create an object from this class But it's not so dynamic, since you still have to write the whole class yourself. Since classes are objects, they must be generated by something. When you use the class keyword, Python creates this object automatically. But as with most things in Python, it gives you a way to do it manually. Remember the function type? The good old function that lets you know what type an object is: >>> print(type(1)) >>> print(type(\"1\")) >>> print(type(ObjectCreator)) >>> print(type(ObjectCreator())) Well, type also has a completely different ability: it can create classes on the fly. type can take the description of a class as parameters, and return a class. (I know, it's silly that the same function can have two completely different uses according to the parameters you pass to it. It's an issue due to backward compatibility in Python) type works this way: type(name, bases, attrs) Where: • name: name of the class • bases: tuple of the parent class (for inheritance, can be empty) • attrs: dictionary containing attributes names and values e.g.: >>> class MyShinyClass(object): ... pass can be created manually this way: >>> MyShinyClass = type('MyShinyClass', (), {}) # returns a class object >>> print(MyShinyClass) >>> print(MyShinyClass()) # create an instance with the class You'll notice that we use MyShinyClass as the name of the class and as the variable to hold the class reference. They can be different, but there is no reason to complicate things. type accepts a dictionary to define the attributes of the class. So: >>> class Foo(object): ... bar = True Can be translated to: >>> Foo = type('Foo', (), {'bar':True}) And used as a normal class: >>> print(Foo) >>> print(Foo.bar) True >>> f = Foo() >>> print(f) >>> print(f.bar) True And of course, you can inherit from it, so: >>> class FooChild(Foo): ... pass would be: >>> FooChild = type('FooChild', (Foo,), {}) >>> print(FooChild) >>> print(FooChild.bar) # bar is inherited from Foo True Eventually, you'll want to add methods to your class. Just define a function with the proper signature and assign it as an attribute. >>> def echo_bar(self): ... print(self.bar) >>> FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar}) >>> hasattr(Foo, 'echo_bar') False >>> hasattr(FooChild, 'echo_bar') True >>> my_foo = FooChild() >>> my_foo.echo_bar() True And you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object. >>> def echo_bar_more(self): ... print('yet another method') >>> FooChild.echo_bar_more = echo_bar_more >>> hasattr(FooChild, 'echo_bar_more') True You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically. This is what Python does when you use the keyword class, and it does so by using a metaclass. What are metaclasses (finally) Metaclasses are the 'stuff' that creates classes. You define classes in order to create objects, right? But we learned that Python classes are objects. Well, metaclasses are what create these objects. They are the classes' classes, you can picture them this way: MyClass = MetaClass() my_object = MyClass() You've seen that type lets you do something like this: MyClass = type('MyClass', (), {}) It's because the function type is in fact a metaclass. type is the metaclass Python uses to create all classes behind the scenes. Now you wonder \"why the heck is it written in lowercase, and not Type?\" Well, I guess it's a matter of consistency with str, the class that creates strings objects, and int the class that creates integer objects. type is just the class that creates class objects. You see that by checking the __class__ attribute. Everything, and I mean everything, is an object in Python. That includes integers, strings, functions and classes. All of them are objects. And all of them have been created from a class: >>> age = 35 >>> age.__class__ >>> name = 'bob' >>> name.__class__ >>> def foo(): pass >>> foo.__class__ >>> class Bar(object): pass >>> b = Bar() >>> b.__class__ Now, what is the __class__ of any __class__ ? >>> age.__class__.__class__ >>> name.__class__.__class__ >>> foo.__class__.__class__ >>> b.__class__.__class__ So, a metaclass is just the stuff that creates class objects. You can call it a 'class factory' if you wish. type is the built-in metaclass Python uses, but of course, you can create your own metaclass. The __metaclass__ attribute In Python 2, you can add a __metaclass__ attribute when you write a class (see next section for the Python 3 syntax): class Foo(object): __metaclass__ = something... [...] If you do so, Python will use the metaclass to create the class Foo. Careful, it's tricky. You write class Foo(object) first, but the class object Foo is not created in memory yet. Python will look for __metaclass__ in the class definition. If it finds it, it will use it to create the class object Foo. If it doesn't, it will use type to create the class. Read that several times. When you do: class Foo(Bar): pass Python does the following: Is there a __metaclass__ attribute in Foo? If yes, create in-memory a class object (I said a class object, stay with me here), with the name Foo by using what is in __metaclass__. If Python can't find __metaclass__, it will look for a __metaclass__ at the MODULE level, and try to do the same (but only for classes that don't inherit anything, basically old-style classes). Then if it can't find any __metaclass__ at all, it will use the Bar's (the first parent) own metaclass (which might be the default type) to create the class object. Be careful here that the __metaclass__ attribute will not be inherited, the metaclass of the parent (Bar.__class__) will be. If Bar used a __metaclass__ attribute that created Bar with type() (and not type.__new__()), the subclasses will not inherit that behavior. Now the big question is, what can you put in __metaclass__? The answer is something that can create a class. And what can create a class? type, or anything that subclasses or uses it. Metaclasses in Python 3 The syntax to set the metaclass has been changed in Python 3: class Foo(object, metaclass=something): ... i.e. the __metaclass__ attribute is no longer used, in favor of a keyword argument in the list of base classes. The behavior of metaclasses however stays largely the same. One thing added to metaclasses in Python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so: class Foo(object, metaclass=something, kwarg1=value1, kwarg2=value2): ... Read the section below for how Python handles this. Custom metaclasses The main purpose of a metaclass is to change the class automatically, when it's created. You usually do this for APIs, where you want to create classes matching the current context. Imagine a stupid example, where you decide that all classes in your module should have their attributes written in uppercase. There are several ways to do this, but one way is to set __metaclass__ at the module level. This way, all classes of this module will be created using this metaclass, and we just have to tell the metaclass to turn all attributes to uppercase. Luckily, __metaclass__ can actually be any callable, it doesn't need to be a formal class (I know, something with 'class' in its name doesn't need to be a class, go figure... but it's helpful). So we will start with a simple example, by using a function. # the metaclass will automatically get passed the same argument # that you usually pass to `type` def upper_attr(future_class_name, future_class_parents, future_class_attrs): \"\"\" Return a class object, with the list of its attribute turned into uppercase. \"\"\" # pick up any attribute that doesn't start with '__' and uppercase it uppercase_attrs = { attr if attr.startswith(\"__\") else attr.upper(): v for attr, v in future_class_attrs.items() } # let `type` do the class creation return type(future_class_name, future_class_parents, uppercase_attrs) __metaclass__ = upper_attr # this will affect all classes in the module class Foo(): # global __metaclass__ won't work with \"object\" though # but we can define __metaclass__ here instead to affect only this class # and this will work with \"object\" children bar = 'bip' Let's check: >>> hasattr(Foo, 'bar') False >>> hasattr(Foo, 'BAR') True >>> Foo.BAR 'bip' Now, let's do exactly the same, but using a real class for a metaclass: # remember that `type` is actually a class like `str` and `int` # so you can inherit from it class UpperAttrMetaclass(type): # __new__ is the method called before __init__ # it's the method that creates the object and returns it # while __init__ just initializes the object passed as parameter # you rarely use __new__, except when you want to control how the object # is created. # here the created object is the class, and we want to customize it # so we override __new__ # you can do some stuff in __init__ too if you wish # some advanced use involves overriding __call__ as well, but we won't # see this def __new__( upperattr_metaclass, future_class_name, future_class_parents, future_class_attrs ): uppercase_attrs = { attr if attr.startswith(\"__\") else attr.upper(): v for attr, v in future_class_attrs.items() } return type(future_class_name, future_class_parents, uppercase_attrs) Let's rewrite the above, but with shorter and more realistic variable names now that we know what they mean: class UpperAttrMetaclass(type): def __new__(cls, clsname, bases, attrs): uppercase_attrs = { attr if attr.startswith(\"__\") else attr.upper(): v for attr, v in attrs.items() } return type(clsname, bases, uppercase_attrs) You may have noticed the extra argument cls. There is nothing special about it: __new__ always receives the class it's defined in, as the first parameter. Just like you have self for ordinary methods which receive the instance as the first parameter, or the defining class for class methods. But this is not proper OOP. We are calling type directly and we aren't overriding or calling the parent's __new__. Let's do that instead: class UpperAttrMetaclass(type): def __new__(cls, clsname, bases, attrs): uppercase_attrs = { attr if attr.startswith(\"__\") else attr.upper(): v for attr, v in attrs.items() } return type.__new__(cls, clsname, bases, uppercase_attrs) We can make it even cleaner by using super, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type): class UpperAttrMetaclass(type): def __new__(cls, clsname, bases, attrs): uppercase_attrs = { attr if attr.startswith(\"__\") else attr.upper(): v for attr, v in attrs.items() } # Python 2 requires passing arguments to super: return super(UpperAttrMetaclass, cls).__new__( cls, clsname, bases, uppercase_attrs) # Python 3 can use no-arg super() which infers them: return super().__new__(cls, clsname, bases, uppercase_attrs) Oh, and in Python 3 if you do this call with keyword arguments, like this: class Foo(object, metaclass=MyMetaclass, kwarg1=value1): ... It translates to this in the metaclass to use it: class MyMetaclass(type): def __new__(cls, clsname, bases, dct, kwarg1=default): ... That's it. There is really nothing more about metaclasses. The reason behind the complexity of the code using metaclasses is not because of metaclasses, it's because you usually use metaclasses to do twisted stuff relying on introspection, manipulating inheritance, vars such as __dict__, etc. Indeed, metaclasses are especially useful to do black magic, and therefore complicated stuff. But by themselves, they are simple: • intercept a class creation • modify the class • return the modified class Why would you use metaclasses classes instead of functions? Since __metaclass__ can accept any callable, why would you use a class since it's obviously more complicated? There are several reasons to do so: • The intention is clear. When you read UpperAttrMetaclass(type), you know what's going to follow • You can use OOP. Metaclass can inherit from metaclass, override parent methods. Metaclasses can even use metaclasses. • Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function. • You can structure your code better. You never use metaclasses for something as trivial as the above example. It's usually for something complicated. Having the ability to make several methods and group them in one class is very useful to make the code easier to read. • You can hook on __new__, __init__ and __call__. Which will allow you to do different stuff, Even if usually you can do it all in __new__, some people are just more comfortable using __init__. • These are called metaclasses, damn it! It must mean something! Why would you use metaclasses? Now the big question. Why would you use some obscure error-prone feature? Well, usually you don't: Metaclasses are deeper magic that 99% of users should never worry about it. If you wonder whether you need them, you don't (the people who actually need them know with certainty that they need them, and don't need an explanation about why). Python Guru Tim Peters The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this: class Person(models.Model): name = models.CharField(max_length=30) age = models.IntegerField() But if you do this: person = Person(name='bob', age='35') print(person.age) It won't return an IntegerField object. It will return an int, and can even take it directly from the database. This is possible because models.Model defines __metaclass__ and it uses some magic that will turn the Person you just defined with simple statements into a complex hook to a database field. Django makes something complex look simple by exposing a simple API and using metaclasses, recreating code from this API to do the real job behind the scenes. The last word First, you know that classes are objects that can create instances. Well, in fact, classes are themselves instances. Of metaclasses. >>> class Foo(object): pass >>> id(Foo) 142630324 Everything is an object in Python, and they are all either instance of classes or instances of metaclasses. Except for type. type is actually its own metaclass. This is not something you could reproduce in pure Python, and is done by cheating a little bit at the implementation level. Secondly, metaclasses are complicated. You may not want to use them for very simple class alterations. You can change classes by using two different techniques: • monkey patching • class decorators 99% of the time you need class alteration, you are better off using these. But 98% of the time, you don't need class alteration at all."
  },
  {
    "id": 5,
    "question": "How do I check whether a file exists without exceptions?",
    "answer": "If the reason you're checking is so you can do something like if file_exists: open_it(), it's safer to use a try around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it. If you're not planning to open the file immediately, you can use os.path.isfile if you need to be sure it's a file. Return True if path is an existing regular file. This follows symbolic links, so both islink() and isfile() can be true for the same path. import os.path os.path.isfile(fname) pathlib Starting with Python 3.4, the pathlib module offers an object-oriented approach (backported to pathlib2 in Python 2.7): from pathlib import Path my_file = Path(\"/path/to/file\") if my_file.is_file(): # file exists To check a directory, do: if my_file.is_dir(): # directory exists To check whether a Path object exists independently of whether is it a file or directory, use exists(): if my_file.exists(): # path exists You can also use resolve(strict=True) in a try block: try: my_abs_path = my_file.resolve(strict=True) except FileNotFoundError: # doesn't exist else: # exists"
  },
  {
    "id": 6,
    "question": "How do I merge two dictionaries in a single expression in Python?",
    "answer": "How can I merge two Python dictionaries in a single expression? For dictionaries x and y, their shallowly-merged dictionary z takes values from y, replacing those from x. • In Python 3.9.0 or greater (released 17 October 2020, PEP-584, discussed here): z = x | y • In Python 3.5 or greater: z = {**x, **y} • In Python 2, (or 3.4 or lower) write a function: def merge_two_dicts(x, y): z = x.copy() # start with keys and values of x z.update(y) # modifies z with keys and values of y return z and now: z = merge_two_dicts(x, y) Explanation Say you have two dictionaries and you want to merge them into a new dictionary without altering the original dictionaries: x = {'a': 1, 'b': 2} y = {'b': 3, 'c': 4} The desired result is to get a new dictionary (z) with the values merged, and the second dictionary's values overwriting those from the first. >>> z {'a': 1, 'b': 3, 'c': 4} A new syntax for this, proposed in PEP 448 and available as of Python 3.5, is z = {**x, **y} And it is indeed a single expression. Note that we can merge in with literal notation as well: z = {**x, 'foo': 1, 'bar': 2, **y} and now: >>> z {'a': 1, 'b': 3, 'foo': 1, 'bar': 2, 'c': 4} It is now showing as implemented in the release schedule for 3.5, PEP 478, and it has now made its way into the What's New in Python 3.5 document. However, since many organizations are still on Python 2, you may wish to do this in a backward-compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process: z = x.copy() z.update(y) # which returns None since it mutates z In both approaches, y will come second and its values will replace x's values, thus b will point to 3 in our final result. Not yet on Python 3.5, but want a single expression If you are not yet on Python 3.5 or need to write backward-compatible code, and you want this in a single expression, the most performant while the correct approach is to put it in a function: def merge_two_dicts(x, y): \"\"\"Given two dictionaries, merge them into a new dict as a shallow copy.\"\"\" z = x.copy() z.update(y) return z and then you have a single expression: z = merge_two_dicts(x, y) You can also make a function to merge an arbitrary number of dictionaries, from zero to a very large number: def merge_dicts(*dict_args): \"\"\" Given any number of dictionaries, shallow copy and merge into a new dict, precedence goes to key-value pairs in latter dictionaries. \"\"\" result = {} for dictionary in dict_args: result.update(dictionary) return result This function will work in Python 2 and 3 for all dictionaries. e.g. given dictionaries a to g: z = merge_dicts(a, b, c, d, e, f, g) and key-value pairs in g will take precedence over dictionaries a to f, and so on. Critiques of Other Answers Don't use what you see in the formerly accepted answer: z = dict(x.items() + y.items()) In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. In Python 3, this will fail because you're adding two dict_items objects together, not two lists - >>> c = dict(a.items() + b.items()) Traceback (most recent call last): File \"\", line 1, in TypeError: unsupported operand type(s) for +: 'dict_items' and 'dict_items' and you would have to explicitly create them as lists, e.g. z = dict(list(x.items()) + list(y.items())). This is a waste of resources and computation power. Similarly, taking the union of items() in Python 3 (viewitems() in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this: >>> c = dict(a.items() | b.items()) This example demonstrates what happens when values are unhashable: >>> x = {'a': []} >>> y = {'b': []} >>> dict(x.items() | y.items()) Traceback (most recent call last): File \"\", line 1, in TypeError: unhashable type: 'list' Here's an example where y should have precedence, but instead the value from x is retained due to the arbitrary order of sets: >>> x = {'a': 2} >>> y = {'a': 1} >>> dict(x.items() | y.items()) {'a': 2} Another hack you should not use: z = dict(x, **y) This uses the dict constructor and is very fast and memory-efficient (even slightly more so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic. Here's an example of the usage being remediated in django. Dictionaries are intended to take hashable keys (e.g. frozensets or tuples), but this method fails in Python 3 when keys are not strings. >>> c = dict(a, **b) Traceback (most recent call last): File \"\", line 1, in TypeError: keyword arguments must be strings From the mailing list, Guido van Rossum, the creator of the language, wrote: I am fine with declaring dict({}, **{1:3}) illegal, since after all it is abuse of the ** mechanism. and Apparently dict(x, **y) is going around as \"cool hack\" for \"call x.update(y) and return x\". Personally, I find it more despicable than cool. It is my understanding (as well as the understanding of the creator of the language) that the intended usage for dict(**y) is for creating dictionaries for readability purposes, e.g.: dict(a=1, b=10, c=11) instead of {'a': 1, 'b': 10, 'c': 11} Response to comments Despite what Guido says, dict(x, **y) is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-coming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact, ** was designed precisely to pass dictionaries as keywords. Again, it doesn't work for 3 when keys are not strings. The implicit calling contract is that namespaces take ordinary dictionaries, while users must only pass keyword arguments that are strings. All other callables enforced it. dict broke this consistency in Python 2: >>> foo(**{('a', 'b'): None}) Traceback (most recent call last): File \"\", line 1, in TypeError: foo() keywords must be strings >>> dict(**{('a', 'b'): None}) {('a', 'b'): None} This inconsistency was bad given other implementations of Python (PyPy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change. I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints. More comments: dict(x.items() + y.items()) is still the most readable solution for Python 2. Readability counts. My response: merge_two_dicts(x, y) actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated. {**x, **y} does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word \"merging\" these answers describe \"updating one dict with another\", and not merging. Yes. I must refer you back to the question, which is asking for a shallow merge of two dictionaries, with the first's values being overwritten by the second's - in a single expression. Assuming two dictionaries of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dictionaries from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them: from copy import deepcopy def dict_of_dicts_merge(x, y): z = {} overlapping_keys = x.keys() & y.keys() for key in overlapping_keys: z[key] = dict_of_dicts_merge(x[key], y[key]) for key in x.keys() - overlapping_keys: z[key] = deepcopy(x[key]) for key in y.keys() - overlapping_keys: z[key] = deepcopy(y[key]) return z Usage: >>> x = {'a':{1:{}}, 'b': {2:{}}} >>> y = {'b':{10:{}}, 'c': {11:{}}} >>> dict_of_dicts_merge(x, y) {'b': {2: {}, 10: {}}, 'a': {1: {}}, 'c': {11: {}}} Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at my answer to the canonical question on a \"Dictionaries of dictionaries merge\". Less Performant But Correct Ad-hocs These approaches are less performant, but they will provide correct behavior. They will be much less performant than copy and update or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they do respect the order of precedence (latter dictionaries have precedence) You can also chain the dictionaries manually inside a dict comprehension: {k: v for d in dicts for k, v in d.items()} # iteritems in Python 2.7 or in Python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced): dict((k, v) for d in dicts for k, v in d.items()) # iteritems in Python 2 itertools.chain will chain the iterators over the key-value pairs in the correct order: from itertools import chain z = dict(chain(x.items(), y.items())) # iteritems in Python 2 Performance Analysis I'm only going to do the performance analysis of the usages known to behave correctly. (Self-contained so you can copy and paste yourself.) from timeit import repeat from itertools import chain x = dict.fromkeys('abcdefg') y = dict.fromkeys('efghijk') def merge_two_dicts(x, y): z = x.copy() z.update(y) return z min(repeat(lambda: {**x, **y})) min(repeat(lambda: merge_two_dicts(x, y))) min(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()})) min(repeat(lambda: dict(chain(x.items(), y.items())))) min(repeat(lambda: dict(item for d in (x, y) for item in d.items()))) In Python 3.8.1, NixOS: >>> min(repeat(lambda: {**x, **y})) 1.0804965235292912 >>> min(repeat(lambda: merge_two_dicts(x, y))) 1.636518670246005 >>> min(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()})) 3.1779992282390594 >>> min(repeat(lambda: dict(chain(x.items(), y.items())))) 2.740647904574871 >>> min(repeat(lambda: dict(item for d in (x, y) for item in d.items()))) 4.266070580109954 $ uname -a Linux nixos 4.19.113 #1-NixOS SMP Wed Mar 25 07:06:15 UTC 2020 x86_64 GNU/Linux Resources on Dictionaries • My explanation of Python's dictionary implementation, updated for 3.6. • Answer on how to add new keys to a dictionary • Mapping two lists into a dictionary • The official Python docs on dictionaries • The Dictionary Even Mightier - talk by Brandon Rhodes at Pycon 2017 • Modern Python Dictionaries, A Confluence of Great Ideas - talk by Raymond Hettinger at Pycon 2017"
  },
  {
    "id": 7,
    "question": "How do I execute a program or call a system command?",
    "answer": "Use subprocess.run: import subprocess subprocess.run([\"ls\", \"-l\"]) Another common way is os.system but you shouldn't use it because it is unsafe if any parts of the command come from outside your program or can contain spaces or other special characters, also subprocess.run is generally more flexible (you can get the stdout, stderr, the \"real\" status code, better error handling, etc.). Even the documentation for os.system recommends using subprocess instead. On Python 3.4 and earlier, use subprocess.call instead of .run: subprocess.call([\"ls\", \"-l\"])"
  },
  {
    "id": 8,
    "question": "How do I create a directory, and any missing parent directories?",
    "answer": "On Python ≥ 3.5, use pathlib.Path.mkdir: from pathlib import Path Path(\"/my/directory\").mkdir(parents=True, exist_ok=True) For older versions of Python, I see two answers with good qualities, each with a small flaw, so I will give my take on it: Try os.path.exists, and consider os.makedirs for the creation. import os if not os.path.exists(directory): os.makedirs(directory) As noted in comments and elsewhere, there's a race condition – if the directory is created between the os.path.exists and the os.makedirs calls, the os.makedirs will fail with an OSError. Unfortunately, blanket-catching OSError and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc. One option would be to trap the OSError and examine the embedded error code (see Is there a cross-platform way of getting information from Python’s OSError): import os, errno try: os.makedirs(directory) except OSError as e: if e.errno != errno.EEXIST: raise Alternatively, there could be a second os.path.exists, but suppose another created the directory after the first check, then removed it before the second one – we could still be fooled. Depending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation. Modern versions of Python improve this code quite a bit, both by exposing FileExistsError (in 3.3+)... try: os.makedirs(\"path/to/directory\") except FileExistsError: # directory already exists pass ...and by allowing a keyword argument to os.makedirs called exist_ok (in 3.2+). os.makedirs(\"path/to/directory\", exist_ok=True) # succeeds even if directory exists."
  },
  {
    "id": 9,
    "question": "How can I access the index value in a 'for' loop?",
    "answer": "Use the built-in function enumerate(): for idx, x in enumerate(xs): print(idx, x) It is non-Pythonic to manually index via for i in range(len(xs)): x = xs[i] or manually manage an additional state variable. Check out PEP 279 for more."
  },
  {
    "id": 10,
    "question": "How do I make a flat list out of a list of lists?",
    "answer": "A list of lists named xss can be flattened using a nested list comprehension: flat_list = [ x for xs in xss for x in xs ] The above is equivalent to: flat_list = [] for xs in xss: for x in xs: flat_list.append(x) Here is the corresponding function: def flatten(xss): return [x for xs in xss for x in xs] This is the fastest method. As evidence, using the timeit module in the standard library, we see: $ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' '[x for xs in xss for x in xs]' 10000 loops, best of 3: 143 usec per loop $ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'sum(xss, [])' 1000 loops, best of 3: 969 usec per loop $ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'reduce(lambda xs, ys: xs + ys, xss)' 1000 loops, best of 3: 1.1 msec per loop Explanation: the methods based on + (including the implied use in sum) are, of necessity, O(L**2) when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of M items each: the first M items are copied back and forth L-1 times, the second M items L-2 times, and so on; total number of copies is M times the sum of x for x from 1 to L excluded, i.e., M * (L**2)/2. The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once."
  },
  {
    "id": 11,
    "question": "What is the difference between @staticmethod and @classmethod in Python?",
    "answer": "Maybe a bit of example code will help: Notice the difference in the call signatures of foo, class_foo and static_foo: class A(object): def foo(self, x): print(f\"executing foo({self}, {x})\") @classmethod def class_foo(cls, x): print(f\"executing class_foo({cls}, {x})\") @staticmethod def static_foo(x): print(f\"executing static_foo({x})\") a = A() Below is the usual way an object instance calls a method. The object instance, a, is implicitly passed as the first argument. a.foo(1) # executing foo(, 1) With classmethods, the class of the object instance is implicitly passed as the first argument instead of self. a.class_foo(1) # executing class_foo(, 1) You can also call class_foo using the class. In fact, if you define something to be a classmethod, it is probably because you intend to call it from the class rather than from a class instance. A.foo(1) would have raised a TypeError, but A.class_foo(1) works just fine: A.class_foo(1) # executing class_foo(, 1) One use people have found for class methods is to create inheritable alternative constructors. With staticmethods, neither self (the object instance) nor cls (the class) is implicitly passed as the first argument. They behave like plain functions except that you can call them from an instance or the class: a.static_foo(1) # executing static_foo(1) A.static_foo('hi') # executing static_foo(hi) Staticmethods are used to group functions which have some logical connection with a class to the class. foo is just a function, but when you call a.foo you don't just get the function, you get a \"partially applied\" version of the function with the object instance a bound as the first argument to the function. foo expects 2 arguments, while a.foo only expects 1 argument. a is bound to foo. That is what is meant by the term \"bound\" below: print(a.foo) # <bound method A.foo of > With a.class_foo, a is not bound to class_foo, rather the class A is bound to class_foo. print(a.class_foo) # <bound method type.class_foo of > Here, with a staticmethod, even though it is a method, a.static_foo just returns a good 'ole function with no arguments bound. static_foo expects 1 argument, and a.static_foo expects 1 argument too. print(a.static_foo) # And of course the same thing happens when you call static_foo with the class A instead. print(A.static_foo) #"
  },
  {
    "id": 12,
    "question": "How slicing in Python works",
    "answer": "The syntax is: a[start:stop] # items start through stop-1 a[start:] # items start through the rest of the array a[:stop] # items from the beginning through stop-1 a[:] # a copy of the whole array There is also the step value, which can be used with any of the above: a[start:stop:step] # start through not past stop, by step The key point to remember is that the :stop value represents the first value that is not in the selected slice. So, the difference between stop and start is the number of elements selected (if step is 1, the default). The other feature is that start or stop may be a negative number, which means it counts from the end of the array instead of the beginning. So: a[-1] # last item in the array a[-2:] # last two items in the array a[:-2] # everything except the last two items Similarly, step may be a negative number: a[::-1] # all items in the array, reversed a[1::-1] # the first two items, reversed a[:-3:-1] # the last two items, reversed a[-3::-1] # everything except the last two items, reversed Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for a[:-2] and a only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen. Relationship with the slice object A slice object can represent a slicing operation, i.e.: a[start:stop:step] is equivalent to: a[slice(start, stop, step)] Slice objects also behave slightly differently depending on the number of arguments, similar to range(), i.e. both slice(stop) and slice(start, stop[, step]) are supported. To skip specifying a given argument, one might use None, so that e.g. a[start:] is equivalent to a[slice(start, None)] or a[::-1] is equivalent to a[slice(None, None, -1)]. While the :-based notation is very helpful for simple slicing, the explicit use of slice() objects simplifies the programmatic generation of slicing."
  },
  {
    "id": 13,
    "question": "How can I find the index for a given item in a list?",
    "answer": ">>> [\"foo\", \"bar\", \"baz\"].index(\"bar\") 1 See the documentation for the built-in .index() method of the list: list.index(x[, start[, end]]) Return zero-based index in the list of the first item whose value is equal to x. Raises a ValueError if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Caveats Linear time-complexity in list length An index call checks every element of the list in order, until it finds a match. If the list is long, and if there is no guarantee that the value will be near the beginning, this can slow down the code. This problem can only be completely avoided by using a different data structure. However, if the element is known to be within a certain part of the list, the start and end parameters can be used to narrow the search. For example: >>> import timeit >>> timeit.timeit('l.index(999_999)', setup='l = list(range(0, 1_000_000))', number=1000) 9.356267921015387 >>> timeit.timeit('l.index(999_999, 999_990, 1_000_000)', setup='l = list(range(0, 1_000_000))', number=1000) 0.0004404920036904514 The second call is orders of magnitude faster, because it only has to search through 10 elements, rather than all 1 million. Only the index of the first match is returned A call to index searches through the list in order until it finds a match, and stops there. If there could be more than one occurrence of the value, and all indices are needed, index cannot solve the problem: >>> [1, 1].index(1) # the `1` index is not found. 0 Instead, use a list comprehension or generator expression to do the search, with enumerate to get indices: >>> # A list comprehension gives a list of indices directly: >>> [i for i, e in enumerate([1, 2, 1]) if e == 1] [0, 2] >>> # A generator comprehension gives us an iterable object... >>> g = (i for i, e in enumerate([1, 2, 1]) if e == 1) >>> # which can be used in a `for` loop, or manually iterated with `next`: >>> next(g) 0 >>> next(g) 2 The list comprehension and generator expression techniques still work if there is only one match, and are more generalizable. Raises an exception if there is no match As noted in the documentation above, using .index will raise an exception if the searched-for value is not in the list: >>> [1, 1].index(2) Traceback (most recent call last): File \"\", line 1, in ValueError: 2 is not in list If this is a concern, either explicitly check first using item in my_list, or handle the exception with try/except as appropriate. The explicit check is simple and readable, but it must iterate the list a second time. See What is the EAFP principle in Python? for more guidance on this choice."
  },
  {
    "id": 14,
    "question": "Iterating over a dictionary using a 'for' loop, getting keys",
    "answer": "key is just a variable name. for key in d: will simply loop over the keys in the dictionary, rather than the keys and values. To loop over both key and value you can use the following: For Python 3.x: for key, value in d.items(): For Python 2.x: for key, value in d.iteritems(): To test for yourself, change the word key to poop. In Python 3.x, iteritems() was replaced with simply items(), which returns a set-like view backed by the dict, like iteritems() but even better. This is also available in 2.7 as viewitems(). The operation items() will work for both 2 and 3, but in 2 it will return a list of the dictionary's (key, value) pairs, which will not reflect changes to the dict that happen after the items() call. If you want the 2.x behavior in 3.x, you can call list(d.items())."
  },
  {
    "id": 15,
    "question": "How can I iterate over rows in a Pandas DataFrame?",
    "answer": "DataFrame.iterrows is a generator which yields both the index and row (as a Series): import pandas as pd df = pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 120]}) df = df.reset_index() # make sure indexes pair with number of rows for index, row in df.iterrows(): print(row['c1'], row['c2']) 10 100 11 110 12 120 Obligatory disclaimer from the documentation Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed and can be avoided with one of the following approaches: • Look for a vectorized solution: many operations can be performed using built-in methods or NumPy functions, (boolean) indexing, … • When you have a function that cannot work on the full DataFrame/Series at once, it is better to use apply() instead of iterating over the values. See the docs on function application. • If you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the enhancing performance section for some examples of this approach. Other answers in this thread delve into greater depth on alternatives to iter* functions if you are interested to learn more."
  },
  {
    "id": 16,
    "question": "How can I use a global variable in a function?",
    "answer": "You can use a global variable within other functions by declaring it as global within each function that assigns a value to it: globvar = 0 def set_globvar_to_one(): global globvar # Needed to modify global copy of globvar globvar = 1 def print_globvar(): print(globvar) # No need for global declaration to read value of globvar set_globvar_to_one() print_globvar() # Prints 1 Since it's unclear whether globvar = 1 is creating a local variable or changing a global variable, Python defaults to creating a local variable, and makes you explicitly choose the other behavior with the global keyword. See other answers if you want to share a global variable across modules."
  },
  {
    "id": 17,
    "question": "How do I get the current time in Python?",
    "answer": "Use datetime: >>> import datetime >>> now = datetime.datetime.now() >>> now datetime.datetime(2009, 1, 6, 15, 8, 24, 78915) >>> print(now) 2009-01-06 15:08:24.789150 For just the clock time without the date: >>> now.time() datetime.time(15, 8, 24, 78915) >>> print(now.time()) 15:08:24.789150 To save typing, you can import the datetime object from the datetime module: >>> from datetime import datetime Then remove the prefix datetime. from all of the above."
  },
  {
    "id": 18,
    "question": "How can I catch multiple exceptions in one line? (in the \"except\" block)",
    "answer": "From Python Documentation: An except clause may name multiple exceptions as a parenthesized tuple, for example except (IDontLikeYouException, YouAreBeingMeanException) as e: pass Or, for Python 2 only: except (IDontLikeYouException, YouAreBeingMeanException), e: pass Separating the exception from the variable with a comma will still work in Python 2.6 and 2.7, but is now deprecated and does not work in Python 3; now you should be using as."
  },
  {
    "id": 19,
    "question": "How do I copy a file?",
    "answer": "shutil has many methods you can use. One of which is: import shutil shutil.copyfile(src, dst) # 2nd option shutil.copy(src, dst) # dst can be a folder; use shutil.copy2() to preserve timestamp • Copy the contents of the file named src to a file named dst. Both src and dst need to be the entire filename of the files, including path. • The destination location must be writable; otherwise, an IOError exception will be raised. • If dst already exists, it will be replaced. • Special files such as character or block devices and pipes cannot be copied with this function. • With copy, src and dst are path names given as strs. Another shutil method to look at is shutil.copy2(). It's similar but preserves more metadata (e.g. time stamps). If you use os.path operations, use copy rather than copyfile. copyfile will only accept strings."
  },
  {
    "id": 20,
    "question": "What is __init__.py for?",
    "answer": "It used to be a required part of a package (old, pre-3.3 \"regular package\", not newer 3.3+ \"namespace package\"). Here's the documentation. Python defines two types of packages, regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an __init__.py file. When a regular package is imported, this __init__.py file is implicitly executed, and the objects it defines are bound to names in the package’s namespace. The __init__.py file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported. But just click the link, it contains an example, more information, and an explanation of namespace packages, the kind of packages without __init__.py."
  },
  {
    "id": 21,
    "question": "Convert bytes to a string in Python 3",
    "answer": "Decode the bytes object to produce a string: >>> b\"abcde\".decode(\"utf-8\") 'abcde' The above example assumes that the bytes object is in UTF-8, because it is a common encoding. However, you should use the encoding your data is actually in!"
  },
  {
    "id": 22,
    "question": "What is the difference between __str__ and __repr__?",
    "answer": "Alex Martelli summarized well but, surprisingly, was too succinct. First, let me reiterate the main points in Alex’s post: • The default implementation is useless (it’s hard to think of one which wouldn’t be, but yeah) • __repr__ goal is to be unambiguous • __str__ goal is to be readable • Container’s __str__ uses contained objects’ __repr__ Default implementation is useless This is mostly a surprise because Python’s defaults tend to be fairly useful. However, in this case, having a default for __repr__ which would act like: return \"%s(%r)\" % (self.__class__, self.__dict__) Or in new f-string formatting: return f\"{self.__class__!s}({self.__dict__!r})\" would have been too dangerous (for example, too easy to get into infinite recursion if objects reference each other). So Python cops out. Note that there is one default which is true: if __repr__ is defined, and __str__ is not, the object will behave as though __str__=__repr__. This means, in simple terms: almost every object you implement should have a functional __repr__ that’s usable for understanding the object. Implementing __str__ is optional: do that if you need a “pretty print” functionality (for example, used by a report generator). The goal of __repr__ is to be unambiguous Let me come right out and say it — I do not believe in debuggers. I don’t really know how to use any debugger, and have never used one seriously. Furthermore, I believe that the big fault in debuggers is their basic nature — most failures I debug happened a long long time ago, in a galaxy far far away. This means that I do believe, with religious fervor, in logging. Logging is the lifeblood of any decent fire-and-forget server system. Python makes it easy to log: with maybe some project specific wrappers, all you need is a log(INFO, \"I am in the weird function and a is\", a, \"and b is\", b, \"but I got a null C — using default\", default_c) But you have to do the last step — make sure every object you implement has a useful repr, so code like that can just work. This is why the “eval” thing comes up: if you have enough information so eval(repr(c))==c, that means you know everything there is to know about c. If that’s easy enough, at least in a fuzzy way, do it. If not, make sure you have enough information about c anyway. I usually use an eval-like format: \"MyClass(this=%r,that=%r)\" % (self.this,self.that). It does not mean that you can actually construct MyClass, or that those are the right constructor arguments — but it is a useful form to express “this is everything you need to know about this instance”. Note: I used %r above, not %s. You always want to use repr() [or %r formatting character, equivalently] inside __repr__ implementation, or you’re defeating the goal of repr. You want to be able to differentiate MyClass(3) and MyClass(\"3\"). The goal of __str__ is to be readable Specifically, it is not intended to be unambiguous — notice that str(3)==str(\"3\"). Likewise, if you implement an IP abstraction, having the str of it look like 192.168.1.1 is just fine. When implementing a date/time abstraction, the str can be \"2010/4/12 15:35:22\", etc. The goal is to represent it in a way that a user, not a programmer, would want to read it. Chop off useless digits, pretend to be some other class — as long is it supports readability, it is an improvement. Container’s __str__ uses contained objects’ __repr__ This seems surprising, doesn’t it? It is a little, but how readable would it be if it used their __str__? [moshe is, 3, hello world, this is a list, oh I don't know, containing just 4 elements] Not very. Specifically, the strings in a container would find it way too easy to disturb its string representation. In the face of ambiguity, remember, Python resists the temptation to guess. If you want the above behavior when you’re printing a list, just print(\"[\" + \", \".join(lst) + \"]\") (you can probably also figure out what to do about dictionaries). Summary Implement __repr__ for any class you implement. This should be second nature. Implement __str__ if you think it would be useful to have a string version which errs on the side of readability."
  },
  {
    "id": 23,
    "question": "How do I select rows from a DataFrame based on column values?",
    "answer": "To select rows whose column value equals a scalar, some_value, use ==: df.loc[df['column_name'] == some_value] To select rows whose column value is in an iterable, some_values, use isin: df.loc[df['column_name'].isin(some_values)] Combine multiple conditions with &: df.loc[(df['column_name'] >= A) & (df['column_name'] <= B)] Note the parentheses. Due to Python's operator precedence rules, & binds more tightly than =. Thus, the parentheses in the last example are necessary. Without the parentheses df['column_name'] >= A & df['column_name'] = (A & df['column_name']) <= B which results in a Truth value of a Series is ambiguous error. To select rows whose column value does not equal some_value, use !=: df.loc[df['column_name'] != some_value] The isin returns a boolean Series, so to select rows whose value is not in some_values, negate the boolean Series using ~: df = df.loc[~df['column_name'].isin(some_values)] # .loc is not in-place replacement For example, import pandas as pd import numpy as np df = pd.DataFrame({'A': 'foo bar foo bar foo bar foo foo'.split(), 'B': 'one one two three two two one three'.split(), 'C': np.arange(8), 'D': np.arange(8) * 2}) print(df) # A B C D # 0 foo one 0 0 # 1 bar one 1 2 # 2 foo two 2 4 # 3 bar three 3 6 # 4 foo two 4 8 # 5 bar two 5 10 # 6 foo one 6 12 # 7 foo three 7 14 print(df.loc[df['A'] == 'foo']) yields A B C D 0 foo one 0 0 2 foo two 2 4 4 foo two 4 8 6 foo one 6 12 7 foo three 7 14 If you have multiple values you want to include, put them in a list (or more generally, any iterable) and use isin: print(df.loc[df['B'].isin(['one','three'])]) yields A B C D 0 foo one 0 0 1 bar one 1 2 3 bar three 3 6 6 foo one 6 12 7 foo three 7 14 Note, however, that if you wish to do this many times, it is more efficient to make an index first, and then use df.loc: df = df.set_index(['B']) print(df.loc['one']) yields A C D B one foo 0 0 one bar 1 2 one foo 6 12 or, to include multiple values from the index use df.index.isin: df.loc[df.index.isin(['one','two'])] yields A C D B one foo 0 0 one bar 1 2 two foo 2 4 two foo 4 8 two bar 5 10 one foo 6 12"
  },
  {
    "id": 24,
    "question": "How can I add new keys to a dictionary?",
    "answer": "You create a new key/value pair on a dictionary by assigning a value to that key d = {'key': 'value'} print(d) # {'key': 'value'} d['mynewkey'] = 'mynewvalue' print(d) # {'key': 'value', 'mynewkey': 'mynewvalue'} If the key doesn't exist, it's added and points to that value. If it exists, the current value it points to is overwritten."
  },
  {
    "id": 25,
    "question": "Does Python have a string 'contains' substring method?",
    "answer": "Use the in operator: if \"blah\" not in somestring: continue Note: This is case-sensitive."
  },
  {
    "id": 26,
    "question": "How can I delete a file or folder in Python?",
    "answer": "Use one of these methods: • pathlib.Path.unlink() removes a file or symbolic link. • pathlib.Path.rmdir() removes an empty directory. • shutil.rmtree() deletes a directory and all its contents. On Python 3.3 and below, you can use these methods instead of the pathlib ones: • os.remove() removes a file. • os.unlink() removes a symbolic link. • os.rmdir() removes an empty directory."
  },
  {
    "id": 27,
    "question": "\"Least Astonishment\" and the Mutable Default Argument",
    "answer": "Actually, this is not a design flaw, and it is not because of internals or performance. It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code. As soon as you think of it this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of \"member data\" and therefore their state may change from one call to the other - exactly as in any other object. In any case, the Effbot (Fredrik Lundh) has a very nice explanation of the reasons for this behavior in Default Parameter Values in Python. I found it very clear, and I really suggest reading it for a better knowledge of how function objects work."
  },
  {
    "id": 28,
    "question": "What does ** (double star/asterisk) and * (star/asterisk) do for parameters?",
    "answer": "The *args and **kwargs are common idioms to allow an arbitrary number of arguments to functions, as described in the section more on defining functions in the Python tutorial. The *args will give you all positional arguments as a tuple: def foo(*args): for a in args: print(a) foo(1) # 1 foo(1, 2, 3) # 1 # 2 # 3 The **kwargs will give you all keyword arguments as a dictionary: def bar(**kwargs): for a in kwargs: print(a, kwargs[a]) bar(name='one', age=27) # name one # age 27 Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments: def foo(kind, *args, bar=None, **kwargs): print(kind, args, bar, kwargs) foo(123, 'a', 'b', apple='red') # 123 ('a', 'b') None {'apple': 'red'} It is also possible to use this the other way around: def foo(a, b, c): print(a, b, c) obj = {'b':10, 'c':'lee'} foo(100, **obj) # 100 10 lee Another usage of the *l idiom is to unpack argument lists when calling a function. def foo(bar, lee): print(bar, lee) baz = [1, 2] foo(*baz) # 1 2 In Python 3 it is possible to use *l on the left side of an assignment (Extended Iterable Unpacking), though it gives a list instead of a tuple in this context: first, *rest = [1, 2, 3, 4] # first = 1 # rest = [2, 3, 4] Also Python 3 adds a new semantic (refer PEP 3102): def func(arg1, arg2, arg3, *, kwarg1, kwarg2): pass Such function accepts only 3 positional arguments, and everything after * can only be passed as keyword arguments. Note: A Python dict, semantically used for keyword argument passing, is arbitrarily ordered. However, in Python 3.6+, keyword arguments are guaranteed to remember insertion order. \"The order of elements in **kwargs now corresponds to the order in which keyword arguments were passed to the function.\" - What’s New In Python 3.6. In fact, all dicts in CPython 3.6 will remember insertion order as an implementation detail, and this becomes standard in Python 3.7."
  },
  {
    "id": 29,
    "question": "How do I list all files of a directory?",
    "answer": "os.listdir() returns everything inside a directory -- including both files and directories. os.path's isfile() can be used to only list files: from os import listdir from os.path import isfile, join onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))] Alternatively, os.walk() yields two lists for each directory it visits -- one for files and one for dirs. If you only want the top directory you can break the first time it yields: from os import walk f = [] for (dirpath, dirnames, filenames) in walk(mypath): f.extend(filenames) break or, shorter: from os import walk filenames = next(walk(mypath), (None, None, []))[2] # [] if no file"
  },
  {
    "id": 30,
    "question": "How can I access environment variables in Python?",
    "answer": "Environment variables are accessed through os.environ: import os print(os.environ['HOME']) To see a list of all environment variables: print(os.environ) If a key is not present, attempting to access it will raise a KeyError. To avoid this: # Returns `None` if the key doesn't exist print(os.environ.get('KEY_THAT_MIGHT_EXIST')) # Returns `default_value` if the key doesn't exist print(os.environ.get('KEY_THAT_MIGHT_EXIST', default_value)) # Returns `default_value` if the key doesn't exist print(os.getenv('KEY_THAT_MIGHT_EXIST', default_value))"
  },
  {
    "id": 31,
    "question": "How do I sort a dictionary by value?",
    "answer": "Python 3.7+ or CPython 3.6 Dicts preserve insertion order in Python 3.7+. Same in CPython 3.6, but it's an implementation detail. >>> x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0} >>> {k: v for k, v in sorted(x.items(), key=lambda item: item[1])} {0: 0, 2: 1, 1: 2, 4: 3, 3: 4} or >>> dict(sorted(x.items(), key=lambda item: item[1])) {0: 0, 2: 1, 1: 2, 4: 3, 3: 4} Older Python It is not possible to sort a dictionary, only to get a representation of a dictionary that is sorted. Dictionaries are inherently orderless, but other types, such as lists and tuples, are not. So you need an ordered data type to represent sorted values, which will be a list—probably a list of tuples. For instance, import operator x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0} sorted_x = sorted(x.items(), key=operator.itemgetter(1)) sorted_x will be a list of tuples sorted by the second element in each tuple. dict(sorted_x) == x. And for those wishing to sort on keys instead of values: import operator x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0} sorted_x = sorted(x.items(), key=operator.itemgetter(0)) In Python3 since unpacking is not allowed we can use x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0} sorted_x = sorted(x.items(), key=lambda kv: kv[1]) If you want the output as a dict, you can use collections.OrderedDict: import collections sorted_dict = collections.OrderedDict(sorted_x)"
  },
  {
    "id": 32,
    "question": "How do I clone a list so that it doesn't change unexpectedly after assignment?",
    "answer": "new_list = my_list doesn't actually create a second list. The assignment just copies the reference to the list, not the actual list, so both new_list and my_list refer to the same list after the assignment. To actually copy the list, you have several options: • You can use the built-in list.copy() method (available since Python 3.3): new_list = old_list.copy() • You can slice it: new_list = old_list[:] Alex Martelli's opinion (at least back in 2007) about this is, that it is a weird syntax and it does not make sense to use it ever. ;) (In his opinion, the next one is more readable). • You can use the built-in list() constructor: new_list = list(old_list) • You can use generic copy.copy(): import copy new_list = copy.copy(old_list) This is a little slower than list() because it has to find out the datatype of old_list first. • If you need to copy the elements of the list as well, use generic copy.deepcopy(): import copy new_list = copy.deepcopy(old_list) Obviously the slowest and most memory-needing method, but sometimes unavoidable. This operates recursively; it will handle any number of levels of nested lists (or other containers). Example: import copy class Foo(object): def __init__(self, val): self.val = val def __repr__(self): return f'Foo({self.val!r})' foo = Foo(1) a = ['foo', foo] b = a.copy() c = a[:] d = list(a) e = copy.copy(a) f = copy.deepcopy(a) # edit orignal list and instance a.append('baz') foo.val = 5 print(f'original: {a} list.copy(): {b} slice: {c} list(): {d} copy: {e} deepcopy: {f}') Result: original: ['foo', Foo(5), 'baz'] list.copy(): ['foo', Foo(5)] slice: ['foo', Foo(5)] list(): ['foo', Foo(5)] copy: ['foo', Foo(5)] deepcopy: ['foo', Foo(1)]"
  },
  {
    "id": 33,
    "question": "How do I pass a variable by reference?",
    "answer": "Arguments are passed by assignment. The rationale behind this is twofold: • the parameter passed in is actually a reference to an object (but the reference is passed by value) • some data types are mutable, but others aren't So: • If you pass a mutable object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object. • If you pass an immutable object to a method, you still can't rebind the outer reference, and you can't even mutate the object. To make it even more clear, let's have some examples. List - a mutable type Let's try to modify the list that was passed to a method: def try_to_change_list_contents(the_list): print('got', the_list) the_list.append('four') print('changed to', the_list) outer_list = ['one', 'two', 'three'] print('before, outer_list =', outer_list) try_to_change_list_contents(outer_list) print('after, outer_list =', outer_list) Output: before, outer_list = ['one', 'two', 'three'] got ['one', 'two', 'three'] changed to ['one', 'two', 'three', 'four'] after, outer_list = ['one', 'two', 'three', 'four'] Since the parameter passed in is a reference to outer_list, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope. Now let's see what happens when we try to change the reference that was passed in as a parameter: def try_to_change_list_reference(the_list): print('got', the_list) the_list = ['and', 'we', 'can', 'not', 'lie'] print('set to', the_list) outer_list = ['we', 'like', 'proper', 'English'] print('before, outer_list =', outer_list) try_to_change_list_reference(outer_list) print('after, outer_list =', outer_list) Output: before, outer_list = ['we', 'like', 'proper', 'English'] got ['we', 'like', 'proper', 'English'] set to ['and', 'we', 'can', 'not', 'lie'] after, outer_list = ['we', 'like', 'proper', 'English'] Since the the_list parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The the_list was a copy of the outer_list reference, and we had the_list point to a new list, but there was no way to change where outer_list pointed. String - an immutable type It's immutable, so there's nothing we can do to change the contents of the string Now, let's try to change the reference def try_to_change_string_reference(the_string): print('got', the_string) the_string = 'In a kingdom by the sea' print('set to', the_string) outer_string = 'It was many and many a year ago' print('before, outer_string =', outer_string) try_to_change_string_reference(outer_string) print('after, outer_string =', outer_string) Output: before, outer_string = It was many and many a year ago got It was many and many a year ago set to In a kingdom by the sea after, outer_string = It was many and many a year ago Again, since the the_string parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The the_string was a copy of the outer_string reference, and we had the_string point to a new string, but there was no way to change where outer_string pointed. I hope this clears things up a little. EDIT: It's been noted that this doesn't answer the question that @David originally asked, \"Is there something I can do to pass the variable by actual reference?\". Let's work on that. How do we get around this? As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out: def return_a_whole_new_string(the_string): new_string = something_to_do_with_the_old_string(the_string) return new_string # then you could call it like my_string = return_a_whole_new_string(my_string) If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list: def use_a_wrapper_to_simulate_pass_by_reference(stuff_to_change): new_string = something_to_do_with_the_old_string(stuff_to_change[0]) stuff_to_change[0] = new_string # then you could call it like wrapper = [my_string] use_a_wrapper_to_simulate_pass_by_reference(wrapper) do_something_with(wrapper[0]) Although this seems a little cumbersome."
  },
  {
    "id": 34,
    "question": "How do I print colored text to the terminal?",
    "answer": "This somewhat depends on what platform you are on. The most common way to do this is by printing ANSI escape sequences. For a simple example, here's some Python code from the Blender build scripts: class bcolors: HEADER = '\\033[95m' OKBLUE = '\\033[94m' OKCYAN = '\\033[96m' OKGREEN = '\\033[92m' WARNING = '\\033[93m' FAIL = '\\033[91m' ENDC = '\\033[0m' BOLD = '\\033[1m' UNDERLINE = '\\033[4m' To use code like this, you can do something like: print(bcolors.WARNING + \"Warning: No active frommets remain. Continue?\" + bcolors.ENDC) Or, with Python 3.6+: print(f\"{bcolors.WARNING}Warning: No active frommets remain. Continue?{bcolors.ENDC}\") This will work on unixes including OS X, Linux and Windows (provided you use ANSICON, or in Windows 10 provided you enable VT100 emulation). There are ANSI codes for setting the color, moving the cursor, and more. If you are going to get complicated with this (and it sounds like you are if you are writing a game), you should look into the \"curses\" module, which handles a lot of the complicated parts of this for you. The Python Curses HowTO is a good introduction. If you are not using extended ASCII (i.e., not on a PC), you are stuck with the ASCII characters below 127, and '#' or '@' is probably your best bet for a block. If you can ensure your terminal is using a IBM extended ASCII character set, you have many more options. Characters 176, 177, 178 and 219 are the \"block characters\". Some modern text-based programs, such as \"Dwarf Fortress\", emulate text mode in a graphical mode, and use images of the classic PC font. You can find some of these bitmaps that you can use on the Dwarf Fortress Wiki see (user-made tilesets). The Text Mode Demo Contest has more resources for doing graphics in text mode."
  },
  {
    "id": 35,
    "question": "Manually raising (throwing) an exception in Python",
    "answer": "How do I manually throw/raise an exception in Python? Use the most specific Exception constructor that semantically fits your issue. Be specific in your message, e.g.: raise ValueError('A very specific bad thing happened.') Don't raise generic exceptions Avoid raising a generic Exception. To catch it, you'll have to catch all other more specific exceptions that subclass it. Problem 1: Hiding bugs raise Exception('I know Python!') # Don't! If you catch, likely to hide bugs. For example: def demo_bad_catch(): try: raise ValueError('Represents a hidden bug, do not catch this') raise Exception('This is the exception you expect to handle') except Exception as error: print('Caught this error: ' + repr(error)) >>> demo_bad_catch() Caught this error: ValueError('Represents a hidden bug, do not catch this',) Problem 2: Won't catch And more specific catches won't catch the general exception: def demo_no_catch(): try: raise Exception('general exceptions not caught by specific handling') except ValueError as e: print('we will not catch exception: Exception') >>> demo_no_catch() Traceback (most recent call last): File \"\", line 1, in File \"\", line 3, in demo_no_catch Exception: general exceptions not caught by specific handling Best Practices: raise statement Instead, use the most specific Exception constructor that semantically fits your issue. raise ValueError('A very specific bad thing happened') which also handily allows an arbitrary number of arguments to be passed to the constructor: raise ValueError('A very specific bad thing happened', 'foo', 'bar', 'baz') These arguments are accessed by the args attribute on the Exception object. For example: try: some_code_that_may_raise_our_value_error() except ValueError as err: print(err.args) prints ('message', 'foo', 'bar', 'baz') In Python 2.5, an actual message attribute was added to BaseException in favor of encouraging users to subclass Exceptions and stop using args, but the introduction of message and the original deprecation of args has been retracted. Best Practices: except clause When inside an except clause, you might want to, for example, log that a specific type of error happened, and then re-raise. The best way to do this while preserving the stack trace is to use a bare raise statement. For example: logger = logging.getLogger(__name__) try: do_something_in_app_that_breaks_easily() except AppError as error: logger.error(error) raise # just this! # raise AppError # Don't do this, you'll lose the stack trace! Don't modify your errors... but if you insist. You can preserve the stacktrace (and error value) with sys.exc_info(), but this is way more error prone and has compatibility problems between Python 2 and 3, prefer to use a bare raise to re-raise. To explain - the sys.exc_info() returns the type, value, and traceback. type, value, traceback = sys.exc_info() This is the syntax in Python 2 - note this is not compatible with Python 3: raise AppError, error, sys.exc_info()[2] # avoid this. # Equivalently, as error *is* the second object: raise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2] If you want to, you can modify what happens with your new raise - e.g. setting new args for the instance: def error(): raise ValueError('oops!') def catch_error_modify_message(): try: error() except ValueError: error_type, error_instance, traceback = sys.exc_info() error_instance.args = (error_instance.args[0] + ' ',) raise error_type, error_instance, traceback And we have preserved the whole traceback while modifying the args. Note that this is not a best practice and it is invalid syntax in Python 3 (making keeping compatibility much harder to work around). >>> catch_error_modify_message() Traceback (most recent call last): File \"\", line 1, in File \"\", line 3, in catch_error_modify_message File \"\", line 2, in error ValueError: oops! In Python 3: raise error.with_traceback(sys.exc_info()[2]) Again: avoid manually manipulating tracebacks. It's less efficient and more error prone. And if you're using threading and sys.exc_info you may even get the wrong traceback (especially if you're using exception handling for control flow - which I'd personally tend to avoid.) Python 3, Exception chaining In Python 3, you can chain Exceptions, which preserve tracebacks: raise RuntimeError('specific message') from error Be aware: • this does allow changing the error type raised, and • this is not compatible with Python 2. Deprecated Methods: These can easily hide and even get into production code. You want to raise an exception, and doing them will raise an exception, but not the one intended! Valid in Python 2, but not in Python 3 is the following: raise ValueError, 'message' # Don't do this, it's deprecated! Only valid in much older versions of Python (2.4 and lower), you may still see people raising strings: raise 'message' # really really wrong. don't do this. In all modern versions, this will actually raise a TypeError, because you're not raising a BaseException type. If you're not checking for the right exception and don't have a reviewer that's aware of the issue, it could get into production. Example Usage I raise Exceptions to warn consumers of my API if they're using it incorrectly: def api_func(foo): '''foo should be either 'baz' or 'bar'. returns something very useful.''' if foo not in _ALLOWED_ARGS: raise ValueError('{foo} wrong, use \"baz\" or \"bar\"'.format(foo=repr(foo))) Create your own error types when apropos \"I want to make an error on purpose, so that it would go into the except\" You can create your own error types, if you want to indicate something specific is wrong with your application, just subclass the appropriate point in the exception hierarchy: class MyAppLookupError(LookupError): '''raise this when there's a lookup error for my app''' and usage: if important_key not in resource_dict and not ok_to_be_missing: raise MyAppLookupError('resource is missing, and that is not ok.')"
  },
  {
    "id": 36,
    "question": "Understanding Python super() with __init__() methods",
    "answer": "super() lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven't already. Note that the syntax changed in Python 3.0: you can just say super().__init__() instead of super(ChildB, self).__init__() which IMO is quite a bit nicer. The standard docs also refer to a guide to using super() which is quite explanatory."
  },
  {
    "id": 37,
    "question": "How do I make a time delay?",
    "answer": "This delays for 2.5 seconds: import time time.sleep(2.5) Here is another example where something is run approximately once a minute: import time while True: print(\"This prints once a minute.\") time.sleep(60) # Delay for 1 minute (60 seconds)."
  },
  {
    "id": 38,
    "question": "How do I change the size of figures drawn with Matplotlib?",
    "answer": "figure tells you the call signature: from matplotlib.pyplot import figure figure(figsize=(8, 6), dpi=80) figure(figsize=(1,1)) would create an inch-by-inch image, which would be 80-by-80 pixels unless you also give a different dpi argument."
  },
  {
    "id": 39,
    "question": "How do I concatenate two lists in Python?",
    "answer": "Use the + operator to combine the lists: listone = [1, 2, 3] listtwo = [4, 5, 6] joinedlist = listone + listtwo Output: >>> joinedlist [1, 2, 3, 4, 5, 6] NOTE: This will create a new list with a shallow copy of the items in the first list, followed by a shallow copy of the items in the second list. Use copy.deepcopy() to get deep copies of lists."
  },
  {
    "id": 40,
    "question": "How do I check if a list is empty?",
    "answer": "if not a: print(\"List is empty\") Using the implicit booleanness of the empty list is quite Pythonic."
  },
  {
    "id": 41,
    "question": "How do I make function decorators and chain them together",
    "answer": "If you are not into long explanations, see Paolo Bergantino’s answer. Decorator Basics Python’s functions are objects To understand decorators, you must first understand that functions are objects in Python. This has important consequences. Let’s see why with a simple example : def shout(word=\"yes\"): return word.capitalize()+\"!\" print(shout()) # outputs : 'Yes!' # As an object, you can assign the function to a variable like any other object scream = shout # Notice we don't use parentheses: we are not calling the function, # we are putting the function \"shout\" into the variable \"scream\". # It means you can then call \"shout\" from \"scream\": print(scream()) # outputs : 'Yes!' # More than that, it means you can remove the old name 'shout', # and the function will still be accessible from 'scream' del shout try: print(shout()) except NameError as e: print(e) #outputs: \"name 'shout' is not defined\" print(scream()) # outputs: 'Yes!' Keep this in mind. We’ll circle back to it shortly. Another interesting property of Python functions is they can be defined inside another function! def talk(): # You can define a function on the fly in \"talk\" ... def whisper(word=\"yes\"): return word.lower()+\"...\" # ... and use it right away! print(whisper()) # You call \"talk\", that defines \"whisper\" EVERY TIME you call it, then # \"whisper\" is called in \"talk\". talk() # outputs: # \"yes...\" # But \"whisper\" DOES NOT EXIST outside \"talk\": try: print(whisper()) except NameError as e: print(e) #outputs : \"name 'whisper' is not defined\"* #Python's functions are objects Functions references Okay, still here? Now the fun part... You’ve seen that functions are objects. Therefore, functions: • can be assigned to a variable • can be defined in another function That means that a function can return another function. def getTalk(kind=\"shout\"): # We define functions on the fly def shout(word=\"yes\"): return word.capitalize()+\"!\" def whisper(word=\"yes\") : return word.lower()+\"...\" # Then we return one of them if kind == \"shout\": # We don't use \"()\", we are not calling the function, # we are returning the function object return shout else: return whisper # How do you use this strange beast? # Get the function and assign it to a variable talk = getTalk() # You can see that \"talk\" is here a function object: print(talk) #outputs : # The object is the one returned by the function: print(talk()) #outputs : Yes! # And you can even use it directly if you feel wild: print(getTalk(\"whisper\")()) #outputs : yes... There’s more! If you can return a function, you can pass one as a parameter: def doSomethingBefore(func): print(\"I do something before then I call the function you gave me\") print(func()) doSomethingBefore(scream) #outputs: #I do something before then I call the function you gave me #Yes! Well, you just have everything needed to understand decorators. You see, decorators are “wrappers”, which means that they let you execute code before and after the function they decorate without modifying the function itself. Handcrafted decorators How you’d do it manually: # A decorator is a function that expects ANOTHER function as parameter def my_shiny_new_decorator(a_function_to_decorate): # Inside, the decorator defines a function on the fly: the wrapper. # This function is going to be wrapped around the original function # so it can execute code before and after it. def the_wrapper_around_the_original_function(): # Put here the code you want to be executed BEFORE the original function is called print(\"Before the function runs\") # Call the function here (using parentheses) a_function_to_decorate() # Put here the code you want to be executed AFTER the original function is called print(\"After the function runs\") # At this point, \"a_function_to_decorate\" HAS NEVER BEEN EXECUTED. # We return the wrapper function we have just created. # The wrapper contains the function and the code to execute before and after. It’s ready to use! return the_wrapper_around_the_original_function # Now imagine you create a function you don't want to ever touch again. def a_stand_alone_function(): print(\"I am a stand alone function, don't you dare modify me\") a_stand_alone_function() #outputs: I am a stand alone function, don't you dare modify me # Well, you can decorate it to extend its behavior. # Just pass it to the decorator, it will wrap it dynamically in # any code you want and return you a new function ready to be used: a_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function) a_stand_alone_function_decorated() #outputs: #Before the function runs #I am a stand alone function, don't you dare modify me #After the function runs Now, you probably want that every time you call a_stand_alone_function, a_stand_alone_function_decorated is called instead. That’s easy, just overwrite a_stand_alone_function with the function returned by my_shiny_new_decorator: a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function) a_stand_alone_function() #outputs: #Before the function runs #I am a stand alone function, don't you dare modify me #After the function runs # That’s EXACTLY what decorators do! Decorators demystified The previous example, using the decorator syntax: @my_shiny_new_decorator def another_stand_alone_function(): print(\"Leave me alone\") another_stand_alone_function() #outputs: #Before the function runs #Leave me alone #After the function runs Yes, that’s all, it’s that simple. @decorator is just a shortcut to: another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function) Decorators are just a pythonic variant of the decorator design pattern. There are several classic design patterns embedded in Python to ease development (like iterators). Of course, you can accumulate decorators: def bread(func): def wrapper(): print(\"\") func() print(\"\") return wrapper def ingredients(func): def wrapper(): print(\"#tomatoes#\") func() print(\"~salad~\") return wrapper def sandwich(food=\"--ham--\"): print(food) sandwich() #outputs: --ham-- sandwich = bread(ingredients(sandwich)) sandwich() #outputs: # # #tomatoes# # --ham-- # ~salad~ # Using the Python decorator syntax: @bread @ingredients def sandwich(food=\"--ham--\"): print(food) sandwich() #outputs: # # #tomatoes# # --ham-- # ~salad~ # The order you set the decorators MATTERS: @ingredients @bread def strange_sandwich(food=\"--ham--\"): print(food) strange_sandwich() #outputs: ##tomatoes# # # --ham-- # # ~salad~ Now: to answer the question... As a conclusion, you can easily see how to answer the question: # The decorator to make it bold def makebold(fn): # The new function the decorator returns def wrapper(): # Insertion of some code before and after return \"\" + fn() + \"\" return wrapper # The decorator to make it italic def makeitalic(fn): # The new function the decorator returns def wrapper(): # Insertion of some code before and after return \"\" + fn() + \"\" return wrapper @makebold @makeitalic def say(): return \"hello\" print(say()) #outputs: hello # This is the exact equivalent to def say(): return \"hello\" say = makebold(makeitalic(say)) print(say()) #outputs: hello You can now just leave happy, or burn your brain a little bit more and see advanced uses of decorators. Taking decorators to the next level Passing arguments to the decorated function # It’s not black magic, you just have to let the wrapper # pass the argument: def a_decorator_passing_arguments(function_to_decorate): def a_wrapper_accepting_arguments(arg1, arg2): print(\"I got args! Look: {0}, {1}\".format(arg1, arg2)) function_to_decorate(arg1, arg2) return a_wrapper_accepting_arguments # Since when you are calling the function returned by the decorator, you are # calling the wrapper, passing arguments to the wrapper will let it pass them to # the decorated function @a_decorator_passing_arguments def print_full_name(first_name, last_name): print(\"My name is {0} {1}\".format(first_name, last_name)) print_full_name(\"Peter\", \"Venkman\") # outputs: #I got args! Look: Peter Venkman #My name is Peter Venkman Decorating methods One nifty thing about Python is that methods and functions are really the same. The only difference is that methods expect that their first argument is a reference to the current object (self). That means you can build a decorator for methods the same way! Just remember to take self into consideration: def method_friendly_decorator(method_to_decorate): def wrapper(self, lie): lie = lie - 3 # very friendly, decrease age even more :-) return method_to_decorate(self, lie) return wrapper class Lucy(object): def __init__(self): self.age = 32 @method_friendly_decorator def sayYourAge(self, lie): print(\"I am {0}, what did you think?\".format(self.age + lie)) l = Lucy() l.sayYourAge(-3) #outputs: I am 26, what did you think? If you’re making general-purpose decorator--one you’ll apply to any function or method, no matter its arguments--then just use *args, **kwargs: def a_decorator_passing_arbitrary_arguments(function_to_decorate): # The wrapper accepts any arguments def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs): print(\"Do I have args?:\") print(args) print(kwargs) # Then you unpack the arguments, here *args, **kwargs # If you are not familiar with unpacking, check: # http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/ function_to_decorate(*args, **kwargs) return a_wrapper_accepting_arbitrary_arguments @a_decorator_passing_arbitrary_arguments def function_with_no_argument(): print(\"Python is cool, no argument here.\") function_with_no_argument() #outputs #Do I have args?: #() #{} #Python is cool, no argument here. @a_decorator_passing_arbitrary_arguments def function_with_arguments(a, b, c): print(a, b, c) function_with_arguments(1,2,3) #outputs #Do I have args?: #(1, 2, 3) #{} #1 2 3 @a_decorator_passing_arbitrary_arguments def function_with_named_arguments(a, b, c, platypus=\"Why not ?\"): print(\"Do {0}, {1} and {2} like platypus? {3}\".format(a, b, c, platypus)) function_with_named_arguments(\"Bill\", \"Linus\", \"Steve\", platypus=\"Indeed!\") #outputs #Do I have args ? : #('Bill', 'Linus', 'Steve') #{'platypus': 'Indeed!'} #Do Bill, Linus and Steve like platypus? Indeed! class Mary(object): def __init__(self): self.age = 31 @a_decorator_passing_arbitrary_arguments def sayYourAge(self, lie=-3): # You can now add a default value print(\"I am {0}, what did you think?\".format(self.age + lie)) m = Mary() m.sayYourAge() #outputs # Do I have args?: #(,) #{} #I am 28, what did you think? Passing arguments to the decorator Great, now what would you say about passing arguments to the decorator itself? This can get somewhat twisted, since a decorator must accept a function as an argument. Therefore, you cannot pass the decorated function’s arguments directly to the decorator. Before rushing to the solution, let’s write a little reminder: # Decorators are ORDINARY functions def my_decorator(func): print(\"I am an ordinary function\") def wrapper(): print(\"I am function returned by the decorator\") func() return wrapper # Therefore, you can call it without any \"@\" def lazy_function(): print(\"zzzzzzzz\") decorated_function = my_decorator(lazy_function) #outputs: I am an ordinary function # It outputs \"I am an ordinary function\", because that’s just what you do: # calling a function. Nothing magic. @my_decorator def lazy_function(): print(\"zzzzzzzz\") #outputs: I am an ordinary function It’s exactly the same. \"my_decorator\" is called. So when you @my_decorator, you are telling Python to call the function 'labelled by the variable \"my_decorator\"'. This is important! The label you give can point directly to the decorator—or not. Let’s get evil. ☺ def decorator_maker(): print(\"I make decorators! I am executed only once: \" \"when you make me create a decorator.\") def my_decorator(func): print(\"I am a decorator! I am executed only when you decorate a function.\") def wrapped(): print(\"I am the wrapper around the decorated function. \" \"I am called when you call the decorated function. \" \"As the wrapper, I return the RESULT of the decorated function.\") return func() print(\"As the decorator, I return the wrapped function.\") return wrapped print(\"As a decorator maker, I return a decorator\") return my_decorator # Let’s create a decorator. It’s just a new function after all. new_decorator = decorator_maker() #outputs: #I make decorators! I am executed only once: when you make me create a decorator. #As a decorator maker, I return a decorator # Then we decorate the function def decorated_function(): print(\"I am the decorated function.\") decorated_function = new_decorator(decorated_function) #outputs: #I am a decorator! I am executed only when you decorate a function. #As the decorator, I return the wrapped function # Let’s call the function: decorated_function() #outputs: #I am the wrapper around the decorated function. I am called when you call the decorated function. #As the wrapper, I return the RESULT of the decorated function. #I am the decorated function. No surprise here. Let’s do EXACTLY the same thing, but skip all the pesky intermediate variables: def decorated_function(): print(\"I am the decorated function.\") decorated_function = decorator_maker()(decorated_function) #outputs: #I make decorators! I am executed only once: when you make me create a decorator. #As a decorator maker, I return a decorator #I am a decorator! I am executed only when you decorate a function. #As the decorator, I return the wrapped function. # Finally: decorated_function() #outputs: #I am the wrapper around the decorated function. I am called when you call the decorated function. #As the wrapper, I return the RESULT of the decorated function. #I am the decorated function. Let’s make it even shorter: @decorator_maker() def decorated_function(): print(\"I am the decorated function.\") #outputs: #I make decorators! I am executed only once: when you make me create a decorator. #As a decorator maker, I return a decorator #I am a decorator! I am executed only when you decorate a function. #As the decorator, I return the wrapped function. #Eventually: decorated_function() #outputs: #I am the wrapper around the decorated function. I am called when you call the decorated function. #As the wrapper, I return the RESULT of the decorated function. #I am the decorated function. Hey, did you see that? We used a function call with the \"@\" syntax! :-) So, back to decorators with arguments. If we can use functions to generate the decorator on the fly, we can pass arguments to that function, right? def decorator_maker_with_arguments(decorator_arg1, decorator_arg2): print(\"I make decorators! And I accept arguments: {0}, {1}\".format(decorator_arg1, decorator_arg2)) def my_decorator(func): # The ability to pass arguments here is a gift from closures. # If you are not comfortable with closures, you can assume it’s ok, # or read: https://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python print(\"I am the decorator. Somehow you passed me arguments: {0}, {1}\".format(decorator_arg1, decorator_arg2)) # Don't confuse decorator arguments and function arguments! def wrapped(function_arg1, function_arg2) : print(\"I am the wrapper around the decorated function. \" \"I can access all the variables \" \"\\t- from the decorator: {0} {1} \" \"\\t- from the function call: {2} {3} \" \"Then I can pass them to the decorated function\" .format(decorator_arg1, decorator_arg2, function_arg1, function_arg2)) return func(function_arg1, function_arg2) return wrapped return my_decorator @decorator_maker_with_arguments(\"Leonard\", \"Sheldon\") def decorated_function_with_arguments(function_arg1, function_arg2): print(\"I am the decorated function and only knows about my arguments: {0}\" \" {1}\".format(function_arg1, function_arg2)) decorated_function_with_arguments(\"Rajesh\", \"Howard\") #outputs: #I make decorators! And I accept arguments: Leonard Sheldon #I am the decorator. Somehow you passed me arguments: Leonard Sheldon #I am the wrapper around the decorated function. #I can access all the variables # - from the decorator: Leonard Sheldon # - from the function call: Rajesh Howard #Then I can pass them to the decorated function #I am the decorated function and only knows about my arguments: Rajesh Howard Here it is: a decorator with arguments. Arguments can be set as variable: c1 = \"Penny\" c2 = \"Leslie\" @decorator_maker_with_arguments(\"Leonard\", c1) def decorated_function_with_arguments(function_arg1, function_arg2): print(\"I am the decorated function and only knows about my arguments:\" \" {0} {1}\".format(function_arg1, function_arg2)) decorated_function_with_arguments(c2, \"Howard\") #outputs: #I make decorators! And I accept arguments: Leonard Penny #I am the decorator. Somehow you passed me arguments: Leonard Penny #I am the wrapper around the decorated function. #I can access all the variables # - from the decorator: Leonard Penny # - from the function call: Leslie Howard #Then I can pass them to the decorated function #I am the decorated function and only know about my arguments: Leslie Howard As you can see, you can pass arguments to the decorator like any function using this trick. You can even use *args, **kwargs if you wish. But remember decorators are called only once. Just when Python imports the script. You can't dynamically set the arguments afterwards. When you do \"import x\", the function is already decorated, so you can't change anything. Let’s practice: decorating a decorator Okay, as a bonus, I'll give you a snippet to make any decorator accept generically any argument. After all, in order to accept arguments, we created our decorator using another function. We wrapped the decorator. Anything else we saw recently that wrapped function? Oh yes, decorators! Let’s have some fun and write a decorator for the decorators: def decorator_with_args(decorator_to_enhance): \"\"\" This function is supposed to be used as a decorator. It must decorate an other function, that is intended to be used as a decorator. Take a cup of coffee. It will allow any decorator to accept an arbitrary number of arguments, saving you the headache to remember how to do that every time. \"\"\" # We use the same trick we did to pass arguments def decorator_maker(*args, **kwargs): # We create on the fly a decorator that accepts only a function # but keeps the passed arguments from the maker. def decorator_wrapper(func): # We return the result of the original decorator, which, after all, # IS JUST AN ORDINARY FUNCTION (which returns a function). # Only pitfall: the decorator must have this specific signature or it won't work: return decorator_to_enhance(func, *args, **kwargs) return decorator_wrapper return decorator_maker It can be used as follows: # You create the function you will use as a decorator. And stick a decorator on it :-) # Don't forget, the signature is \"decorator(func, *args, **kwargs)\" @decorator_with_args def decorated_decorator(func, *args, **kwargs): def wrapper(function_arg1, function_arg2): print(\"Decorated with {0} {1}\".format(args, kwargs)) return func(function_arg1, function_arg2) return wrapper # Then you decorate the functions you wish with your brand new decorated decorator. @decorated_decorator(42, 404, 1024) def decorated_function(function_arg1, function_arg2): print(\"Hello {0} {1}\".format(function_arg1, function_arg2)) decorated_function(\"Universe and\", \"everything\") #outputs: #Decorated with (42, 404, 1024) {} #Hello Universe and everything # Whoooot! I know, the last time you had this feeling, it was after listening a guy saying: \"before understanding recursion, you must first understand recursion\". But now, don't you feel good about mastering this? Best practices: decorators • Decorators were introduced in Python 2.4, so be sure your code will be run on >= 2.4. • Decorators slow down the function call. Keep that in mind. • You cannot un-decorate a function. (There are hacks to create decorators that can be removed, but nobody uses them.) So once a function is decorated, it’s decorated for all the code. • Decorators wrap functions, which can make them hard to debug. (This gets better from Python >= 2.5; see below.) The functools module was introduced in Python 2.5. It includes the function functools.wraps(), which copies the name, module, and docstring of the decorated function to its wrapper. (Fun fact: functools.wraps() is a decorator! ☺) # For debugging, the stacktrace prints you the function __name__ def foo(): print(\"foo\") print(foo.__name__) #outputs: foo # With a decorator, it gets messy def bar(func): def wrapper(): print(\"bar\") return func() return wrapper @bar def foo(): print(\"foo\") print(foo.__name__) #outputs: wrapper # \"functools\" can help for that import functools def bar(func): # We say that \"wrapper\", is wrapping \"func\" # and the magic begins @functools.wraps(func) def wrapper(): print(\"bar\") return func() return wrapper @bar def foo(): print(\"foo\") print(foo.__name__) #outputs: foo How can the decorators be useful? Now the big question: What can I use decorators for? Seem cool and powerful, but a practical example would be great. Well, there are 1000 possibilities. Classic uses are extending a function behavior from an external lib (you can't modify it), or for debugging (you don't want to modify it because it’s temporary). You can use them to extend several functions in a DRY’s way, like so: def benchmark(func): \"\"\" A decorator that prints the time a function takes to execute. \"\"\" import time def wrapper(*args, **kwargs): t = time.clock() res = func(*args, **kwargs) print(\"{0} {1}\".format(func.__name__, time.clock()-t)) return res return wrapper def logging(func): \"\"\" A decorator that logs the activity of the script. (it actually just prints it, but it could be logging!) \"\"\" def wrapper(*args, **kwargs): res = func(*args, **kwargs) print(\"{0} {1} {2}\".format(func.__name__, args, kwargs)) return res return wrapper def counter(func): \"\"\" A decorator that counts and prints the number of times a function has been executed \"\"\" def wrapper(*args, **kwargs): wrapper.count = wrapper.count + 1 res = func(*args, **kwargs) print(\"{0} has been used: {1}x\".format(func.__name__, wrapper.count)) return res wrapper.count = 0 return wrapper @counter @benchmark @logging def reverse_string(string): return str(reversed(string)) print(reverse_string(\"Able was I ere I saw Elba\")) print(reverse_string(\"A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!\")) #outputs: #reverse_string ('Able was I ere I saw Elba',) {} #wrapper 0.0 #wrapper has been used: 1x #ablE was I ere I saw elbA #reverse_string ('A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!',) {} #wrapper 0.0 #wrapper has been used: 2x #!amanaP :lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A Of course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said: @counter @benchmark @logging def get_random_futurama_quote(): from urllib import urlopen result = urlopen(\"http://subfusion.net/cgi-bin/quote.pl?quote=futurama\").read() try: value = result.split(\" \")[1].split(\" \")[0] return value.strip() except: return \"No, I'm ... doesn't!\" print(get_random_futurama_quote()) print(get_random_futurama_quote()) #outputs: #get_random_futurama_quote () {} #wrapper 0.02 #wrapper has been used: 1x #The laws of science be a harsh mistress. #get_random_futurama_quote () {} #wrapper 0.01 #wrapper has been used: 2x #Curse you, merciful Poseidon! Python itself provides several decorators: property, staticmethod, etc. • Django uses decorators to manage caching and view permissions. • Twisted to fake inlining asynchronous functions calls. This really is a large playground."
  },
  {
    "id": 42,
    "question": "How do I split a list into equally-sized chunks?",
    "answer": "Here's a generator that yields evenly-sized chunks: def chunks(lst, n): \"\"\"Yield successive n-sized chunks from lst.\"\"\" for i in range(0, len(lst), n): yield lst[i:i + n] import pprint pprint.pprint(list(chunks(range(10, 75), 10))) [[10, 11, 12, 13, 14, 15, 16, 17, 18, 19], [20, 21, 22, 23, 24, 25, 26, 27, 28, 29], [30, 31, 32, 33, 34, 35, 36, 37, 38, 39], [40, 41, 42, 43, 44, 45, 46, 47, 48, 49], [50, 51, 52, 53, 54, 55, 56, 57, 58, 59], [60, 61, 62, 63, 64, 65, 66, 67, 68, 69], [70, 71, 72, 73, 74]] For Python 2, using xrange instead of range: def chunks(lst, n): \"\"\"Yield successive n-sized chunks from lst.\"\"\" for i in xrange(0, len(lst), n): yield lst[i:i + n] Below is a list comprehension one-liner. The method above is preferable, though, since using named functions makes code easier to understand. For Python 3: [lst[i:i + n] for i in range(0, len(lst), n)] For Python 2: [lst[i:i + n] for i in xrange(0, len(lst), n)]"
  },
  {
    "id": 43,
    "question": "Find the current directory and file's directory",
    "answer": "To get the full path to the directory a Python file is contained in, write this in that file: import os dir_path = os.path.dirname(os.path.realpath(__file__)) (Note that the incantation above won't work if you've already used os.chdir() to change your current working directory, since the value of the __file__ constant is relative to the current working directory and is not changed by an os.chdir() call.) To get the current working directory use import os cwd = os.getcwd() Documentation references for the modules, constants and functions used above: • The os and os.path modules. • The __file__ constant • os.path.realpath(path) (returns \"the canonical path of the specified filename, eliminating any symbolic links encountered in the path\") • os.path.dirname(path) (returns \"the directory name of pathname path\") • os.getcwd() (returns \"a string representing the current working directory\") • os.chdir(path) (\"change the current working directory to path\")"
  },
  {
    "id": 44,
    "question": "What is the difference between Python's list methods append and extend?",
    "answer": ".append() appends a single object at the end of the list: >>> x = [1, 2, 3] >>> x.append([4, 5]) >>> print(x) [1, 2, 3, [4, 5]] .extend() appends multiple objects that are taken from inside the specified iterable: >>> x = [1, 2, 3] >>> x.extend([4, 5]) >>> print(x) [1, 2, 3, 4, 5]"
  },
  {
    "id": 45,
    "question": "Renaming column names in Pandas",
    "answer": "Rename Specific Columns Use the df.rename() function and refer the columns to be renamed. Not all the columns have to be renamed: df = df.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'}) # Or rename the existing DataFrame (rather than creating a copy) df.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'}, inplace=True) Minimal Code Example df = pd.DataFrame('x', index=range(3), columns=list('abcde')) df a b c d e 0 x x x x x 1 x x x x x 2 x x x x x The following methods all work and produce the same output: df2 = df.rename({'a': 'X', 'b': 'Y'}, axis=1) df2 = df.rename({'a': 'X', 'b': 'Y'}, axis='columns') df2 = df.rename(columns={'a': 'X', 'b': 'Y'}) df2 X Y c d e 0 x x x x x 1 x x x x x 2 x x x x x Remember to assign the result back, as the modification is not-inplace. Alternatively, specify inplace=True: df.rename({'a': 'X', 'b': 'Y'}, axis=1, inplace=True) df X Y c d e 0 x x x x x 1 x x x x x 2 x x x x x You can specify errors='raise' to raise errors if an invalid column-to-rename is specified. Reassign Column Headers Use df.set_axis() with axis=1. df2 = df.set_axis(['V', 'W', 'X', 'Y', 'Z'], axis=1) df2 V W X Y Z 0 x x x x x 1 x x x x x 2 x x x x x Headers can be assigned directly: df.columns = ['V', 'W', 'X', 'Y', 'Z'] df V W X Y Z 0 x x x x x 1 x x x x x 2 x x x x x"
  },
  {
    "id": 46,
    "question": "Why is \"1000000000000000 in range(1000000000000001)\" so fast in Python 3?",
    "answer": "The Python 3 range() object doesn't produce numbers immediately; it is a smart sequence object that produces numbers on demand. All it contains is your start, stop and step values, then as you iterate over the object the next integer is calculated each iteration. The object also implements the object.__contains__ hook, and calculates if your number is part of its range. Calculating is a (near) constant time operation *. There is never a need to scan through all possible integers in the range. From the range() object documentation: The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and subranges as needed). So at a minimum, your range() object would do: class my_range: def __init__(self, start, stop=None, step=1, /): if stop is None: start, stop = 0, start self.start, self.stop, self.step = start, stop, step if step hi else ((hi - lo - 1) // step) + 1 def __iter__(self): current = self.start if self.step self.stop: yield current current += self.step else: while current < self.stop: yield current current += self.step def __len__(self): return self.length def __getitem__(self, i): if i < 0: i += self.length if 0 <= i < self.length: return self.start + i * self.step raise IndexError('my_range object index out of range') def __contains__(self, num): if self.step < 0: if not (self.stop < num <= self.start): return False else: if not (self.start <= num < self.stop): return False return (num - self.start) % self.step == 0 This is still missing several things that a real range() supports (such as the .index() or .count() methods, hashing, equality testing, or slicing), but should give you an idea. I also simplified the __contains__ implementation to only focus on integer tests; if you give a real range() object a non-integer value (including subclasses of int), a slow scan is initiated to see if there is a match, just as if you use a containment test against a list of all the contained values. This was done to continue to support other numeric types that just happen to support equality testing with integers but are not expected to support integer arithmetic as well. See the original Python issue that implemented the containment test. * Near constant time because Python integers are unbounded and so math operations also grow in time as N grows, making this a O(log N) operation. Since it’s all executed in optimised C code and Python stores integer values in 30-bit chunks, you’d run out of memory before you saw any performance impact due to the size of the integers involved here."
  },
  {
    "id": 47,
    "question": "How can I remove a key from a Python dictionary?",
    "answer": "To delete a key regardless of whether it is in the dictionary, use the two-argument form of dict.pop(): my_dict.pop('key', None) This will return my_dict[key] if key exists in the dictionary, and None otherwise. If the second parameter is not specified (i.e. my_dict.pop('key')) and key does not exist, a KeyError is raised. To delete a key that is guaranteed to exist, you can also use del my_dict['key'] This will raise a KeyError if the key is not in the dictionary."
  },
  {
    "id": 48,
    "question": "Convert string \"Jun 1 2005 1:33PM\" into datetime",
    "answer": "datetime.strptime parses an input string in the user-specified format into a timezone-naive datetime object: >>> from datetime import datetime >>> datetime.strptime('Jun 1 2005 1:33PM', '%b %d %Y %I:%M%p') datetime.datetime(2005, 6, 1, 13, 33) To obtain a date object using an existing datetime object, convert it using .date(): >>> datetime.strptime('Jun 1 2005', '%b %d %Y').date() date(2005, 6, 1) Links: • strptime docs: Python 2, Python 3 • strptime/strftime format string docs: Python 2, Python 3 • strftime.org format string cheatsheet Notes: • strptime = \"string parse time\" • strftime = \"string format time\""
  },
  {
    "id": 49,
    "question": "How to upgrade all Python packages with pip",
    "answer": "There isn't a built-in flag yet. Starting with pip version 22.3, the --outdated and --format=freeze have become mutually exclusive. Use Python, to parse the JSON output: pip --disable-pip-version-check list --outdated --format=json | python -c \"import json, sys; print(' '.join([x['name'] for x in json.load(sys.stdin)]))\" | xargs -n1 pip install -U If you are using pip<22.3 you can use: pip list --outdated --format=freeze | grep -v '^\\-e' | cut -d = -f 1 | xargs -n1 pip install -U For older versions of pip: pip freeze --local | grep -v '^\\-e' | cut -d = -f 1 | xargs -n1 pip install -U • The grep is to skip editable (\"-e\") package definitions, as suggested by @jawache. (Yes, you could replace grep+cut with sed or awk or perl or...). • The -n1 flag for xargs prevents stopping everything if updating one package fails (thanks @andsens). Note: there are infinite potential variations for this. I'm trying to keep this answer short and simple, but please do suggest variations in the comments!"
  },
  {
    "id": 50,
    "question": "How can I sort a list of dictionaries by a value of the dictionary in Python?",
    "answer": "The sorted() function takes a key= parameter newlist = sorted(list_to_be_sorted, key=lambda d: d['name']) Alternatively, you can use operator.itemgetter instead of defining the function yourself from operator import itemgetter newlist = sorted(list_to_be_sorted, key=itemgetter('name')) For completeness, add reverse=True to sort in descending order newlist = sorted(list_to_be_sorted, key=itemgetter('name'), reverse=True)"
  },
  {
    "id": 51,
    "question": "How to leave/exit/deactivate a Python virtualenv",
    "answer": "Usually, activating a virtualenv gives you a shell function named: $ deactivate which puts things back to normal. I have just looked specifically again at the code for virtualenvwrapper, and, yes, it too supports deactivate as the way to escape from all virtualenvs. If you are trying to leave an Anaconda environment, the command depends upon your version of conda. Recent versions (like 4.6) install a conda function directly in your shell, in which case you run: conda deactivate Older conda versions instead implement deactivation using a stand-alone script: source deactivate"
  },
  {
    "id": 52,
    "question": "How do I get the last element of a list?",
    "answer": "some_list[-1] is the shortest and most Pythonic. In fact, you can do much more with this syntax. The some_list[-n] syntax gets the nth-to-last element. So some_list[-1] gets the last element, some_list[-2] gets the second to last, etc, all the way down to some_list[-len(some_list)], which gives you the first element. You can also set list elements in this way. For instance: >>> some_list = [1, 2, 3] >>> some_list[-1] = 5 # Set the last element >>> some_list[-2] = 3 # Set the second to last element >>> some_list [1, 3, 5] Note that getting a list item by index will raise an IndexError if the expected item doesn't exist. This means that some_list[-1] will raise an exception if some_list is empty, because an empty list can't have a last element."
  },
  {
    "id": 53,
    "question": "How do I parse a string to a float or int?",
    "answer": ">>> a = \"545.2222\" >>> float(a) 545.22220000000004 >>> int(float(a)) 545"
  },
  {
    "id": 54,
    "question": "How do I install pip on Windows?",
    "answer": "Python 3.4+ and 2.7.9+ Good news! Python 3.4 (released March 2014) and Python 2.7.9 (released December 2014) ship with Pip. This is the best feature of any Python release. It makes the community's wealth of libraries accessible to everyone. Newbies are no longer excluded from using community libraries by the prohibitive difficulty of setup. In shipping with a package manager, Python joins Ruby, Node.js, Haskell, Perl, Go—almost every other contemporary language with a majority open-source community. Thank you, Python. If you do find that pip is not available, simply run ensurepip. • On Windows: py -3 -m ensurepip • Otherwise: python3 -m ensurepip Of course, that doesn't mean Python packaging is problem solved. The experience remains frustrating. I discuss this in the Stack Overflow question Does Python have a package/module management system?. Python 3 ≤ 3.3 and 2 ≤ 2.7.8 Flying in the face of its 'batteries included' motto, Python ships without a package manager. To make matters worse, Pip was—until recently—ironically difficult to install. Official instructions Per https://pip.pypa.io/en/stable/installing/#do-i-need-to-install-pip: Download get-pip.py, being careful to save it as a .py file rather than .txt. Then, run it from the command prompt: python get-pip.py You possibly need an administrator command prompt to do this. Follow Start a Command Prompt as an Administrator (Microsoft TechNet). This installs the pip package, which (in Windows) contains ...\\Scripts\\pip.exe that path must be in PATH environment variable to use pip from the command line (see the second part of 'Alternative Instructions' for adding it to your PATH, Alternative instructions The official documentation tells users to install Pip and each of its dependencies from source. That's tedious for the experienced and prohibitively difficult for newbies. For our sake, Christoph Gohlke prepares Windows installers (.msi) for popular Python packages. He builds installers for all Python versions, both 32 and 64 bit. You need to: • Install setuptools • Install pip For me, this installed Pip at C:\\Python27\\Scripts\\pip.exe. Find pip.exe on your computer, then add its folder (for example, C:\\Python27\\Scripts) to your path (Start / Edit environment variables). Now you should be able to run pip from the command line. Try installing a package: pip install httpie There you go (hopefully)! Solutions for common problems are given below: Proxy problems If you work in an office, you might be behind an HTTP proxy. If so, set the environment variables http_proxy and https_proxy. Most Python applications (and other free software) respect these. Example syntax: http://proxy_url:port http://username:password@proxy_url:port If you're really unlucky, your proxy might be a Microsoft NTLM proxy. Free software can't cope. The only solution is to install a free software friendly proxy that forwards to the nasty proxy. http://cntlm.sourceforge.net/ Unable to find vcvarsall.bat Python modules can be partly written in C or C++. Pip tries to compile from source. If you don't have a C/C++ compiler installed and configured, you'll see this cryptic error message. Error: Unable to find vcvarsall.bat You can fix that by installing a C++ compiler such as MinGW or Visual C++. Microsoft actually ships one specifically for use with Python. Or try Microsoft Visual C++ Compiler for Python 2.7. Often though it's easier to check Christoph's site for your package."
  },
  {
    "id": 55,
    "question": "How do I get a substring of a string in Python?",
    "answer": ">>> x = \"Hello World!\" >>> x[2:] 'llo World!' >>> x[:2] 'He' >>> x[:-2] 'Hello Worl' >>> x[-2:] 'd!' >>> x[2:-2] 'llo Worl' Python calls this concept \"slicing\" and it works on more than just strings. Take a look here for a comprehensive introduction."
  },
  {
    "id": 56,
    "question": "How do I escape curly-brace ({}) characters characters in a string while using .format?",
    "answer": "You need to double the {{ and }}: >>> x = \" {{ Hello }} {0} \" >>> print(x.format(42)) ' { Hello } 42 ' Here's the relevant part of the Python documentation for format string syntax: Format strings contain “replacement fields” surrounded by curly braces {}. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: {{ and }}."
  },
  {
    "id": 57,
    "question": "Check if a given key already exists in a dictionary",
    "answer": "in tests for the existence of a key in a dict: d = {\"key1\": 10, \"key2\": 23} if \"key1\" in d: print(\"this will execute\") if \"nonexistent key\" in d: print(\"this will not\") Use dict.get() to provide a default value when the key does not exist: d = {} for i in range(100): key = i % 10 d[key] = d.get(key, 0) + 1 To provide a default value for every key, either use dict.setdefault() on each assignment: d = {} for i in range(100): d[i % 10] = d.setdefault(i % 10, 0) + 1 ...or better, use defaultdict from the collections module: from collections import defaultdict d = defaultdict(int) for i in range(100): d[i % 10] += 1"
  },
  {
    "id": 58,
    "question": "Importing files from different folder",
    "answer": "Note: This answer was intended for a very specific question. For most programmers coming here from a search engine, this is not the answer you are looking for. Typically you would structure your files into packages (see other answers) instead of modifying the search path. By default, you can't. When importing a file, Python only searches the directory that the entry-point script is running from and sys.path which includes locations such as the package installation directory (it's actually a little more complex than this, but this covers most cases). However, you can add to the Python path at runtime: # some_file.py import sys # caution: path[0] is reserved for script path (or '' in REPL) sys.path.insert(1, '/path/to/application/app/folder') import file"
  },
  {
    "id": 59,
    "question": "Class (static) variables and methods",
    "answer": "Variables declared inside the class definition, but not inside a method are class or static variables: >>> class MyClass: ... i = 3 ... >>> MyClass.i 3 As @millerdev points out, this creates a class-level i variable, but this is distinct from any instance-level i variable, so you could have >>> m = MyClass() >>> m.i = 4 >>> MyClass.i, m.i >>> (3, 4) This is different from C++ and Java, but not so different from C#, where a static member can't be accessed using a reference to an instance. See what the Python tutorial has to say on the subject of classes and class objects. @Steve Johnson has already answered regarding static methods, also documented under \"Built-in Functions\" in the Python Library Reference. class C: @staticmethod def f(arg1, arg2, ...): ... @beidy recommends classmethods over staticmethod, as the method then receives the class type as the first argument."
  },
  {
    "id": 60,
    "question": "How do I lowercase a string in Python?",
    "answer": "Use str.lower(): \"Kilometer\".lower()"
  },
  {
    "id": 61,
    "question": "How can I check if an object has an attribute?",
    "answer": "Try hasattr(): if hasattr(a, 'property'): a.property See zweiterlinde's answer, which offers good advice about asking forgiveness! It is a very Pythonic approach! The general practice in Python is that, if the property is likely to be there most of the time, simply call it and either let the exception propagate, or trap it with a try/except block. This will likely be faster than hasattr. If the property is likely to not be there most of the time, or you're not sure, using hasattr will probably be faster than repeatedly falling into an exception block."
  },
  {
    "id": 62,
    "question": "How to print without a newline or space",
    "answer": "In Python 3, you can use the sep= and end= parameters of the print function: To not add a newline to the end of the string: print('.', end='') To not add a space between all the function arguments you want to print: print('a', 'b', 'c', sep='') You can pass any string to either parameter, and you can use both parameters at the same time. If you are having trouble with buffering, you can flush the output by adding flush=True keyword argument: print('.', end='', flush=True) Python 2.6 and 2.7 From Python 2.6 you can either import the print function from Python 3 using the __future__ module: from __future__ import print_function which allows you to use the Python 3 solution above. However, note that the flush keyword is not available in the version of the print function imported from __future__ in Python 2; it only works in Python 3, more specifically 3.3 and later. In earlier versions you'll still need to flush manually with a call to sys.stdout.flush(). You'll also have to rewrite all other print statements in the file where you do this import. Or you can use sys.stdout.write() import sys sys.stdout.write('.') You may also need to call sys.stdout.flush() to ensure stdout is flushed immediately."
  },
  {
    "id": 63,
    "question": "Calling a function of a module by using its name (a string)",
    "answer": "Given a module foo with method bar: import foo bar = getattr(foo, 'bar') result = bar() getattr can similarly be used on class instance bound methods, module-level methods, class methods... the list goes on."
  },
  {
    "id": 64,
    "question": "Limiting floats to two decimal points",
    "answer": "You are running into the old problem with floating point numbers that not all numbers can be represented exactly. The command line is just showing you the full floating point form from memory. With floating point representation, your rounded version is the same number. Since computers are binary, they store floating point numbers as an integer and then divide it by a power of two so 13.95 will be represented in a similar fashion to 125650429603636838/(2**53). Double precision numbers have 53 bits (16 digits) of precision and regular floats have 24 bits (8 digits) of precision. The floating point type in Python uses double precision to store the values. For example, >>> 125650429603636838/(2**53) 13.949999999999999 >>> 234042163/(2**24) 13.949999988079071 >>> a = 13.946 >>> print(a) 13.946 >>> print(\"%.2f\" % a) 13.95 >>> round(a,2) 13.949999999999999 >>> print(\"%.2f\" % round(a, 2)) 13.95 >>> print(\"{:.2f}\".format(a)) 13.95 >>> print(\"{:.2f}\".format(round(a, 2))) 13.95 >>> print(\"{:.15f}\".format(round(a, 2))) 13.949999999999999 If you are after only two decimal places (to display a currency value, for example), then you have a couple of better choices: • Use integers and store values in cents, not dollars and then divide by 100 to convert to dollars. • Or use a fixed point number like decimal."
  },
  {
    "id": 65,
    "question": "How can I randomly select (choose) an item from a list (get a random element)?",
    "answer": "Use random.choice(): import random foo = ['a', 'b', 'c', 'd', 'e'] print(random.choice(foo)) For cryptographically secure random choices (e.g., for generating a passphrase from a wordlist), use secrets.choice(): import secrets foo = ['battery', 'correct', 'horse', 'staple'] print(secrets.choice(foo)) secrets is new in Python 3.6. On older versions of Python you can use the random.SystemRandom class: import random secure_random = random.SystemRandom() print(secure_random.choice(foo))"
  },
  {
    "id": 66,
    "question": "How to remove an element from a list by index",
    "answer": "Use del and specify the index of the element you want to delete: >>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> del a[-1] >>> a [0, 1, 2, 3, 4, 5, 6, 7, 8] Also supports slices: >>> del a[2:4] >>> a [0, 1, 4, 5, 6, 7, 8, 9] Here is the section from the tutorial."
  },
  {
    "id": 67,
    "question": "Delete a column from a Pandas DataFrame",
    "answer": "The best way to do this in Pandas is to use drop: df = df.drop('column_name', axis=1) where 1 is the axis number (0 for rows and 1 for columns.) Or, the drop() method accepts index/columns keywords as an alternative to specifying the axis. So we can now just do: df = df.drop(columns=['column_nameA', 'column_nameB']) • This was introduced in v0.21.0 (October 27, 2017) To delete the column without having to reassign df you can do: df.drop('column_name', axis=1, inplace=True) Finally, to drop by column number instead of by column label, try this to delete, e.g. the 1st, 2nd and 4th columns: df = df.drop(df.columns[[0, 1, 3]], axis=1) # df.columns is zero-based pd.Index Also working with \"text\" syntax for the columns: df.drop(['column_nameA', 'column_nameB'], axis=1, inplace=True)"
  },
  {
    "id": 68,
    "question": "How do I get the number of elements in a list (length of a list) in Python?",
    "answer": "The len() function can be used with several different types in Python - both built-in types and library types. For example: >>> len([1, 2, 3]) 3"
  },
  {
    "id": 69,
    "question": "What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv, etc?",
    "answer": "This is my personal recommendation for beginners: start by learning virtualenv and pip, tools which work with both Python 2 and 3 and in a variety of situations, and pick up other tools once you start needing them. Now on to answer the question: what is the difference between these similarly named things: venv, virtualenv, etc? PyPI packages not in the standard library: • virtualenv is a very popular tool that creates isolated Python environments for Python libraries. If you're not familiar with this tool, I highly recommend learning it, as it is a very useful tool. It works by installing a bunch of files in a directory (eg: env/), and then modifying the PATH environment variable to prefix it with a custom bin directory (eg: env/bin/). An exact copy of the python or python3 binary is placed in this directory, but Python is programmed to look for libraries relative to its path first, in the environment directory. It's not part of Python's standard library, but is officially blessed by the PyPA (Python Packaging Authority). Once activated, you can install packages in the virtual environment using pip. • pyenv is used to isolate Python versions. For example, you may want to test your code against Python 2.7, 3.6, 3.7 and 3.8, so you'll need a way to switch between them. Once activated, it prefixes the PATH environment variable with ~/.pyenv/shims, where there are special files matching the Python commands (python, pip). These are not copies of the Python-shipped commands; they are special scripts that decide on the fly which version of Python to run based on the PYENV_VERSION environment variable, or the .python-version file, or the ~/.pyenv/version file. pyenv also makes the process of downloading and installing multiple Python versions easier, using the command pyenv install. • pyenv-virtualenv is a plugin for pyenv by the same author as pyenv, to allow you to use pyenv and virtualenv at the same time conveniently. However, if you're using Python 3.3 or later, pyenv-virtualenv will try to run python -m venv if it is available, instead of virtualenv. You can use virtualenv and pyenv together without pyenv-virtualenv, if you don't want the convenience features. • virtualenvwrapper is a set of extensions to virtualenv (see docs). It gives you commands like mkvirtualenv, lssitepackages, and especially workon for switching between different virtualenv directories. This tool is especially useful if you want multiple virtualenv directories. • pyenv-virtualenvwrapper is a plugin for pyenv by the same author as pyenv, to conveniently integrate virtualenvwrapper into pyenv. • pipenv aims to combine Pipfile, pip and virtualenv into one command on the command-line. The virtualenv directory typically gets placed in ~/.local/share/virtualenvs/XXX, with XXX being a hash of the path of the project directory. This is different from virtualenv, where the directory is typically in the current working directory. pipenv is meant to be used when developing Python applications (as opposed to libraries). There are alternatives to pipenv, such as poetry, which I won't list here since this question is only about the packages that are similarly named. Standard library: • pyvenv (not to be confused with pyenv in the previous section) is a script shipped with Python 3.3 to 3.7. It was removed from Python 3.8 as it had problems (not to mention the confusing name). Running python3 -m venv has exactly the same effect as pyvenv. • venv is a package shipped with Python 3, which you can run using python3 -m venv (although for some reason some distros separate it out into a separate distro package, such as python3-venv on Ubuntu/Debian). It serves the same purpose as virtualenv, but only has a subset of its features (see a comparison here). virtualenv continues to be more popular than venv, especially since the former supports both Python 2 and 3."
  },
  {
    "id": 70,
    "question": "How do I pad a string with zeros?",
    "answer": "To pad strings: >>> n = '4' >>> print(n.zfill(3)) 004 To pad numbers: >>> n = 4 >>> print(f'{n:03}') # Preferred method, python >= 3.6 004 >>> print('%03d' % n) 004 >>> print(format(n, '03')) # python >= 2.6 004 >>> print('{0:03d}'.format(n)) # python >= 2.6 + python 3 004 >>> print('{foo:03d}'.format(foo=n)) # python >= 2.6 + python 3 004 >>> print('{:03d}'.format(n)) # python >= 2.7 + python3 004 String formatting documentation."
  },
  {
    "id": 71,
    "question": "How can I determine a Python variable's type?",
    "answer": "Use the type() built-in function: >>> i = 123 >>> type(i) >>> type(i) is int True >>> i = 123.456 >>> type(i) >>> type(i) is float True To check if a variable is of a given type, use isinstance: >>> i = 123 >>> isinstance(i, int) True >>> isinstance(i, (float, str, set, dict)) False Note that Python doesn't have the same types as C/C++, which appears to be your question."
  },
  {
    "id": 72,
    "question": "Delete an element from a dictionary",
    "answer": "The del statement removes an element: del d[key] Note that this mutates the existing dictionary, so the contents of the dictionary changes for anybody else who has a reference to the same instance. To return a new dictionary, make a copy of the dictionary: def removekey(d, key): r = dict(d) del r[key] return r The dict() constructor makes a shallow copy. To make a deep copy, see the copy module. Note that making a copy for every dict del/assignment/etc. means you're going from constant time to linear time, and also using linear space. For small dicts, this is not a problem. But if you're planning to make lots of copies of large dicts, you probably want a different data structure, like a HAMT (as described in this answer)."
  },
  {
    "id": 73,
    "question": "Determine the type of an object?",
    "answer": "There are two built-in functions that help you identify the type of an object. You can use type() if you need the exact type of an object, and isinstance() to check an object’s type against something. Usually, you want to use isinstance() most of the times since it is very robust and also supports type inheritance. To get the actual type of an object, you use the built-in type() function. Passing an object as the only parameter will return the type object of that object: >>> type([]) is list True >>> type({}) is dict True >>> type('') is str True >>> type(0) is int True This of course also works for custom types: >>> class Test1 (object): pass >>> class Test2 (Test1): pass >>> a = Test1() >>> b = Test2() >>> type(a) is Test1 True >>> type(b) is Test2 True Note that type() will only return the immediate type of the object, but won’t be able to tell you about type inheritance. >>> type(b) is Test1 False To cover that, you should use the isinstance function. This of course also works for built-in types: >>> isinstance(b, Test1) True >>> isinstance(b, Test2) True >>> isinstance(a, Test1) True >>> isinstance(a, Test2) False >>> isinstance([], list) True >>> isinstance({}, dict) True isinstance() is usually the preferred way to ensure the type of an object because it will also accept derived types. So unless you actually need the type object (for whatever reason), using isinstance() is preferred over type(). The second parameter of isinstance() also accepts a tuple of types, so it’s possible to check for multiple types at once. isinstance will then return true, if the object is of any of those types: >>> isinstance([], (tuple, list, set)) True"
  },
  {
    "id": 74,
    "question": "How to check if the string is empty in Python?",
    "answer": "Empty strings are \"falsy\" (python 2 or python 3 reference), which means they are considered false in a Boolean context, so you can just do this: if not myString: This is the preferred way if you know that your variable is a string. If your variable could also be some other type then you should use: if myString == \"\": See the documentation on Truth Value Testing for other values that are false in Boolean contexts."
  },
  {
    "id": 75,
    "question": "How do I count the occurrences of a list item?",
    "answer": "If you only want a single item's count, use the count method: >>> [1, 2, 3, 4, 1, 4, 1].count(1) 3 Important: this is very slow if you are counting multiple different items Each count call goes over the entire list of n elements. Calling count in a loop n times means n * n total checks, which can be catastrophic for performance. If you want to count multiple items, use Counter, which only does n total checks."
  },
  {
    "id": 76,
    "question": "Why is reading lines from stdin much slower in C++ than Python?",
    "answer": "tl;dr: Because of different default settings in C++ requiring more system calls. By default, cin is synchronized with stdio, which causes it to avoid any input buffering. If you add this to the top of your main, you should see much better performance: std::ios_base::sync_with_stdio(false); Normally, when an input stream is buffered, instead of reading one character at a time, the stream will be read in larger chunks. This reduces the number of system calls, which are typically relatively expensive. However, since the FILE* based stdio and iostreams often have separate implementations and therefore separate buffers, this could lead to a problem if both were used together. For example: int myvalue1; cin >> myvalue1; int myvalue2; scanf(\"%d\",&myvalue2); If more input was read by cin than it actually needed, then the second integer value wouldn't be available for the scanf function, which has its own independent buffer. This would lead to unexpected results. To avoid this, by default, streams are synchronized with stdio. One common way to achieve this is to have cin read each character one at a time as needed using stdio functions. Unfortunately, this introduces a lot of overhead. For small amounts of input, this isn't a big problem, but when you are reading millions of lines, the performance penalty is significant. Fortunately, the library designers decided that you should also be able to disable this feature to get improved performance if you knew what you were doing, so they provided the sync_with_stdio method. From this link (emphasis added): If the synchronization is turned off, the C++ standard streams are allowed to buffer their I/O independently, which may be considerably faster in some cases."
  },
  {
    "id": 77,
    "question": "How do I measure elapsed time in Python?",
    "answer": "Use time.time() to measure the elapsed wall-clock time between two points: import time start = time.time() print(\"hello\") end = time.time() print(end - start) This gives the execution time in seconds. Another option since Python 3.3 might be to use perf_counter or process_time, depending on your requirements. Before 3.3 it was recommended to use time.clock (thanks Amber). However, it is currently deprecated: On Unix, return the current processor time as a floating point number expressed in seconds. The precision, and in fact the very definition of the meaning of “processor time”, depends on that of the C function of the same name. On Windows, this function returns wall-clock seconds elapsed since the first call to this function, as a floating point number, based on the Win32 function QueryPerformanceCounter(). The resolution is typically better than one microsecond. Deprecated since version 3.3: The behaviour of this function depends on the platform: use perf_counter() or process_time() instead, depending on your requirements, to have a well defined behaviour."
  },
  {
    "id": 78,
    "question": "Why is it string.join(list) instead of list.join(string)?",
    "answer": "It's because any iterable can be joined (e.g, list, tuple, dict, set), but its contents and the \"joiner\" must be strings. For example: '_'.join(['welcome', 'to', 'stack', 'overflow']) '_'.join(('welcome', 'to', 'stack', 'overflow')) 'welcome_to_stack_overflow' Using something other than strings will raise the following error: TypeError: sequence item 0: expected str instance, int found"
  },
  {
    "id": 79,
    "question": "How do I append to a file?",
    "answer": "Set the mode in open() to \"a\" (append) instead of \"w\" (write): with open(\"test.txt\", \"a\") as myfile: myfile.write(\"appended text\") The documentation lists all the available modes."
  },
  {
    "id": 80,
    "question": "Is there a way to run Python on Android?",
    "answer": "One way is to use Kivy: Open source Python library for rapid development of applications that make use of innovative user interfaces, such as multi-touch apps. Kivy runs on Linux, Windows, OS X, Android and iOS. You can run the same [python] code on all supported platforms. Kivy Showcase app"
  },
  {
    "id": 81,
    "question": "How can I remove a trailing newline?",
    "answer": "Try the method rstrip() (see doc Python 2 and Python 3) >>> 'test string '.rstrip() 'test string' Python's rstrip() method strips all kinds of trailing whitespace by default, not just one newline as Perl does with chomp. >>> 'test string \\r \\r '.rstrip() 'test string' To strip only newlines: >>> 'test string \\r \\r '.rstrip(' ') 'test string \\r \\r ' In addition to rstrip(), there are also the methods strip() and lstrip(). Here is an example with the three of them: >>> s = \" \\r abc def \\r \" >>> s.strip() 'abc def' >>> s.lstrip() 'abc def \\r ' >>> s.rstrip() ' \\r abc def'"
  },
  {
    "id": 82,
    "question": "Static methods in Python?",
    "answer": "Yep, using the staticmethod decorator: class MyClass(object): @staticmethod def the_static_method(x): print(x) MyClass.the_static_method(2) # outputs 2 Note that some code might use the old method of defining a static method, using staticmethod as a function rather than a decorator. This should only be used if you have to support ancient versions of Python (2.2 and 2.3): class MyClass(object): def the_static_method(x): print(x) the_static_method = staticmethod(the_static_method) MyClass.the_static_method(2) # outputs 2 This is entirely identical to the first example (using @staticmethod), just not using the nice decorator syntax. Finally, use staticmethod sparingly! There are very few situations where static-methods are necessary in Python, and I've seen them used many times where a separate \"top-level\" function would have been clearer. The following is verbatim from the documentation:: A static method does not receive an implicit first argument. To declare a static method, use this idiom: class C: @staticmethod def f(arg1, arg2, ...): ... The @staticmethod form is a function decorator – see the description of function definitions in Function definitions for details. It can be called either on the class (such as C.f()) or on an instance (such as C().f()). The instance is ignored except for its class. Static methods in Python are similar to those found in Java or C++. For a more advanced concept, see classmethod(). For more information on static methods, consult the documentation on the standard type hierarchy in The standard type hierarchy. New in version 2.2. Changed in version 2.4: Function decorator syntax added."
  },
  {
    "id": 83,
    "question": "Installing specific package version with pip",
    "answer": "TL;DR: Update as of 2022-12-28: pip install --force-reinstall -v For example: pip install --force-reinstall -v \"MySQL_python==1.2.2\" What these options mean: • --force-reinstall is an option to reinstall all packages even if they are already up-to-date. • -v is for verbose. You can combine for even more verbosity (i.e. -vv) up to 3 times (e.g. --force-reinstall -vvv). Thanks to @Peter for highlighting this (and it seems that the context of the question has broadened given the time when the question was first asked!), the documentation for Python discusses a caveat with using -I, in that it can break your installation if it was installed with a different package manager or if if your package is/was a different version. Original answer: • pip install -Iv (i.e. pip install -Iv MySQL_python==1.2.2) What these options mean: • -I stands for --ignore-installed which will ignore the installed packages, overwriting them. • -v is for verbose. You can combine for even more verbosity (i.e. -vv) up to 3 times (e.g. -Ivvv). For more information, see pip install --help First, I see two issues with what you're trying to do. Since you already have an installed version, you should either uninstall the current existing driver or use pip install -I MySQL_python==1.2.2 However, you'll soon find out that this doesn't work. If you look at pip's installation log, or if you do a pip install -Iv MySQL_python==1.2.2 you'll find that the PyPI URL link does not work for MySQL_python v1.2.2. You can verify this here: http://pypi.python.org/pypi/MySQL-python/1.2.2 The download link 404s and the fallback URL links are re-directing infinitely due to sourceforge.net's recent upgrade and PyPI's stale URL. So to properly install the driver, you can follow these steps: pip uninstall MySQL_python pip install -Iv http://sourceforge.net/projects/mysql-python/files/mysql-python/1.2.2/MySQL-python-1.2.2.tar.gz/download"
  },
  {
    "id": 84,
    "question": "How do I split the definition of a long string over multiple lines?",
    "answer": "Are you talking about multi-line strings? Easy, use triple quotes to start and end them. s = \"\"\" this is a very long string if I had the energy to type more and more ...\"\"\" You can use single quotes too (3 of them of course at start and end) and treat the resulting string s just like any other string. NOTE: Just as with any string, anything between the starting and ending quotes becomes part of the string, so this example has a leading blank (as pointed out by @root45). This string will also contain both blanks and newlines. I.e.,: ' this is a very long string if I had the energy to type more and more ...' Finally, one can also construct long lines in Python like this: s = (\"this is a very\" \"long string too\" \"for sure ...\" ) which will not include any extra blanks or newlines (this is a deliberate example showing what the effect of skipping blanks will result in): 'this is a verylong string toofor sure ...' No commas required, simply place the strings to be joined together into a pair of parenthesis and be sure to account for any needed blanks and newlines."
  },
  {
    "id": 85,
    "question": "How to prettyprint a JSON file?",
    "answer": "Use the indent= parameter of json.dump() or json.dumps() to specify how many spaces to indent by: >>> import json >>> your_json = '[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]' >>> parsed = json.loads(your_json) >>> print(json.dumps(parsed, indent=4)) [ \"foo\", { \"bar\": [ \"baz\", null, 1.0, 2 ] } ] To parse a file, use json.load(): with open('filename.txt', 'r') as handle: parsed = json.load(handle)"
  },
  {
    "id": 86,
    "question": "Getting the class name of an instance",
    "answer": "Have you tried the __name__ attribute of the class? ie type(x).__name__ will give you the name of the class, which I think is what you want. >>> import itertools >>> x = itertools.count(0) >>> type(x).__name__ 'count' If you're still using Python 2, note that the above method works with new-style classes only (in Python 3+ all classes are \"new-style\" classes). Your code might use some old-style classes. The following works for both: x.__class__.__name__"
  },
  {
    "id": 87,
    "question": "How do I get the row count of a Pandas DataFrame?",
    "answer": "For a dataframe df, one can use any of the following: • len(df.index) • df.shape[0] • df[df.columns[0]].count() (== number of non-NaN values in first column) Code to reproduce the plot: import numpy as np import pandas as pd import perfplot perfplot.save( \"out.png\", setup=lambda n: pd.DataFrame(np.arange(n * 3).reshape(n, 3)), n_range=[2**k for k in range(25)], kernels=[ lambda df: len(df.index), lambda df: df.shape[0], lambda df: df[df.columns[0]].count(), ], labels=[\"len(df.index)\", \"df.shape[0]\", \"df[df.columns[0]].count()\"], xlabel=\"Number of rows\", )"
  },
  {
    "id": 88,
    "question": "How to read a file line-by-line into a list?",
    "answer": "This code will read the entire file into memory and remove all whitespace characters (newlines and spaces) from the end of each line: with open(filename) as file: lines = [line.rstrip() for line in file] If you're working with a large file, then you should instead read and process it line-by-line: with open(filename) as file: for line in file: print(line.rstrip()) In Python 3.8 and up you can use a while loop with the walrus operator like so: with open(filename) as file: while line := file.readline(): print(line.rstrip()) Depending on what you plan to do with your file and how it was encoded, you may also want to manually set the access mode and character encoding: with open(filename, 'r', encoding='UTF-8') as file: while line := file.readline(): print(line.rstrip())"
  },
  {
    "id": 89,
    "question": "How do I check if a string represents a number (float or int)?",
    "answer": "For non-negative (unsigned) integers only, use isdigit(): >>> a = \"03523\" >>> a.isdigit() True >>> b = \"963spam\" >>> b.isdigit() False Documentation for isdigit(): Python2, Python3 For Python 2 Unicode strings: isnumeric()."
  },
  {
    "id": 90,
    "question": "What's the canonical way to check for type in Python?",
    "answer": "Use isinstance to check if o is an instance of str or any subclass of str: if isinstance(o, str): To check if the type of o is exactly str, excluding subclasses of str: if type(o) is str: See Built-in Functions in the Python Library Reference for relevant information. Checking for strings in Python 2 For Python 2, this is a better way to check if o is a string: if isinstance(o, basestring): because this will also catch Unicode strings. unicode is not a subclass of str; both str and unicode are subclasses of basestring. In Python 3, basestring no longer exists since there's a strict separation of strings (str) and binary data (bytes). Alternatively, isinstance accepts a tuple of classes. This will return True if o is an instance of any subclass of any of (str, unicode): if isinstance(o, (str, unicode)):"
  }
]