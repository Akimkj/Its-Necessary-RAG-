from transformers import BertTokenizer, BertModel
from bert_score import BERTScorer

golden_answer = "Pelo que você escreveu, está faltando um ponto crucial: a diferença entre uma classe e um objeto. ` __init__new` não inicializa uma classe, mas sim uma instância de uma classe ou de um objeto. Cada cachorro tem uma cor, mas os cachorros como classe não têm. Cada cachorro tem quatro patas ou menos, mas a classe de cachorros não tem. A classe é um conceito de um objeto. Quando você vê o Fido e o Spot, você reconhece a semelhança entre eles, o fato de serem cachorros. Isso é a classe. Quando você diz class Dog: def __init__(self, legs, colour): self.legs = legs self.colour = colour fido = Dog(4, 'brown') spot = Dog(3, 'mostly yellow') Você está dizendo que Fido é um cachorro marrom com quatro patas, enquanto Spot é um pouco aleijado e é quase todo amarelo. Essa __init__função é chamada de construtor ou inicializador e é executada automaticamente quando você cria uma nova instância de uma classe. Dentro dessa função, o objeto recém-criado é atribuído ao parâmetro `a` self. A notação ` self.legsa` representa um atributo chamado `a` legsdo objeto na variável `a` self. Atributos são como variáveis, mas descrevem o estado de um objeto ou ações (funções) específicas disponíveis para o objeto. Observe, no entanto, que você não define colouro status do cachorro em si — é um conceito abstrato. Existem atributos que fazem sentido em classes. Por exemplo, ` population_sizeis` é um deles — não faz sentido contar o Fido, porque Fido é sempre um. Faz sentido contar cachorros. Digamos que existam 200 milhões de cachorros no mundo. Essa é a propriedade da classe `Dog`. Fido não tem nada a ver com o número 200 milhões, nem Spot. Isso é chamado de 'atributo de classe', em oposição a 'atributos de instância', que são colour`Object` ou legssuperior. Agora, mudando para algo menos canino e mais relacionado à programação. Como escrevo abaixo, uma classe para adicionar coisas não faz sentido — afinal, do que ela é uma classe? Classes em Python são coleções de dados diferentes que se comportam de maneira semelhante. A classe 'cachorros' consiste em Fido, Spot e outros 199999999998 animais parecidos com eles, todos urinando em postes. Do que consiste a classe para adicionar coisas? Quais são os dados inerentes a elas que as diferenciam? E quais ações elas compartilham? No entanto, números... esses são assuntos mais interessantes. Digamos, números inteiros. Existem muitos deles, muito mais do que cachorros. Eu sei que o Python já tem inteiros, mas vamos fingir que não sabemos e 'implementá-los' novamente (trapaceando e usando os inteiros do Python). Então, os números inteiros são uma classe. Eles têm alguns dados (valor) e alguns comportamentos ('adicione-me a este outro número'). Vamos mostrar isso: class MyInteger: def __init__(self, newvalue): # imagine self as an index card. # under the heading of 'value', we will write # the contents of the variable newvalue. self.value = newvalue def add(self, other): # when an integer wants to add itself to another integer, # we'll take their values and add them together, # then make a new integer with the result value. return MyInteger(self.value + other.value) three = MyInteger(3) five = MyInteger(5) eight = three.add(five) print eight.value Isso é um pouco frágil (estamos assumindo otherque será um MyInteger), mas vamos ignorar por enquanto. Em código real, não faríamos isso; testaríamos para ter certeza e talvez até forçaríamos ('você não é um inteiro? Ora, você tem 10 nanossegundos para se tornar um! 9... 8...'). Poderíamos até definir frações. As frações também sabem somar-se a si mesmas. class MyFraction: def __init__(self, newnumerator, newdenominator): self.numerator = newnumerator self.denominator = newdenominator def add(self, other): newdenominator = self.denominator * other.denominator newnumerator = self.numerator * other.denominator + self.denominator * other.numerator return MyFraction(newnumerator, newdenominator) Existem ainda mais frações do que números inteiros (na verdade, não, mas os computadores não sabem disso). Vamos criar duas: half = MyFraction(1, 2) third = MyFraction(1, 3) five_sixths = half.add(third) print five_sixths.numerator print five_sixths.denominator Na verdade, você não está declarando nada aqui. Atributos são como um novo tipo de variável. Variáveis ​​normais têm apenas um valor. Digamos que você escreva `a == a` colour = 'grey'. Você não pode ter outra variável com o mesmo nome colourque seja 'fuchsia''a' - não no mesmo lugar no código. Os arrays resolvem isso até certo ponto. Se você disser '[0, 1]' colour = ['grey', 'fuchsia'], você empilhou duas cores na variável, mas as distingue por sua posição (0 ou 1, neste caso). Atributos são variáveis ​​associadas a um objeto. Assim como em arrays, podemos ter várias colourvariáveis ​​em diferentes tipos de cachorros . Por exemplo, `Dog` fido.colouré uma variável, mas `Dog` spot.colouré outra. A primeira está associada ao objeto dentro da variável fido`Dog`; a segunda, `Dog` spot. Agora, quando você chama `Dog` Dog(4, 'brown'), `Dog` ou three.add(five)`Dog`, sempre haverá um parâmetro invisível, que será atribuído ao parâmetro extra pendente no início da lista de parâmetros. Ele é convencionalmente chamado de `Dog` self, e receberá o valor do objeto antes do ponto. Assim, dentro do __init__construtor de `Dog`, `Dog` selfserá o que o novo `Dog` se tornará; dentro do MyIntegerconstrutor de `Dog` add, self`Dog` estará associado ao objeto na variável `Dog` three. Portanto, `Dog` three.valueserá a mesma variável fora do construtor add, assim como self.valuedentro dele add. Se eu disser the_mangy_one = fido, começarei a me referir ao objeto conhecido como fidocom mais um nome. De agora em diante, fido.colouré exatamente a mesma variável que the_mangy_one.colour. Então, as coisas dentro do __init__... Você pode pensar nelas como anotações na certidão de nascimento do cachorro. colourO valor em si é uma variável aleatória, podendo conter qualquer coisa. fido.colourOu seja, self.colouré como um campo de formulário na ficha de identidade do cachorro; e __init__representa o funcionário preenchendo-a pela primeira vez."

canditate = "Em Python, o método `__init__` (lê-se \"dunder init\", de *double underscore*) é um método especial, também conhecido como o **construtor** de uma classe. Ele desempenha um papel fundamental na Orientação a Objetos por ser o local onde a inicialização de um objeto recém-criado ocorre. ### Propósito Principal O principal motivo para usarmos `__init__` é para **inicializar os atributos** de um objeto no momento de sua criação. Quando você cria uma nova instância de uma classe, o Python automaticamente chama o método `__init__` dessa classe. É dentro de `__init__` que você define os valores iniciais para as variáveis que pertencem àquela instância específica do objeto. ### Como Funciona 1. **Criação do Objeto**: Quando você escreve `meu_objeto = MinhaClasse(...)`, o Python primeiro cria um novo objeto em branco na memória. 2. **Chamada de `__init__`**: Em seguida, o Python chama automaticamente o método `__init__` desse objeto recém-criado, passando o próprio objeto como o primeiro argumento (`self`) e quaisquer outros argumentos fornecidos na chamada do construtor. 3. **Inicialização dos Atributos**: Dentro de `__init__`, você usa o parâmetro `self` para definir e atribuir valores aos atributos específicos dessa instância (`self.atributo = valor`). ### Por Que É Crucial? * **Estado Consistente**: Garante que cada objeto criado a partir de uma classe comece com um conjunto de atributos bem definidos e um estado inicial válido. Isso evita que você tenha objetos \"vazios\" ou incompletos que precisam ser configurados manualmente após a criação. * **Encapsulamento**: Centraliza a lógica de inicialização dentro da própria classe, tornando-a mais autônoma e fácil de usar. Quem utiliza a classe não precisa se preocupar em quais atributos precisam ser definidos; basta passar os argumentos necessários ao criar o objeto. * **Flexibilidade**: Permite que você passe dados iniciais para um objeto no momento de sua criação, tornando as instâncias personalizáveis. * **Previsibilidade**: Ao saber que `__init__` sempre será chamado, você pode contar que seus objetos estarão em um estado conhecido assim que forem instanciados. ### Exemplo Ilustrativo Vamos comparar uma classe sem e com `__init__` para ver a diferença. #### Exemplo 1: Sem `__init__` (Menos Prático) ```python class Cachorro: # Nenhum __init__ definido pass # Criando um objeto Cachorro meu_cachorro = Cachorro() # Precisamos atribuir os atributos manualmente, um por um meu_cachorro.nome = \"Buddy\" meu_cachorro.raca = \"Golden Retriever\" meu_cachorro.idade = 3 print(f\"Meu cachorro é o {meu_cachorro.nome}, da raça {meu_cachorro.raca}, e tem {meu_cachorro.idade} anos.\") # Se esquecermos de um atributo, ele não existirá # print(meu_cachorro.cor) # Isso geraria um AttributeError ``` Neste exemplo, o objeto `meu_cachorro` é criado sem nenhum atributo predefinido. Temos que atribuí-los manualmente, o que é propenso a erros e menos organizado. #### Exemplo 2: Com `__init__` (Abordagem Padrão e Recomendada) ```python class Cachorro: def __init__(self, nome, raca, idade=0): # 'self' se refere à instância do objeto que está sendo criada. # Atribuímos os argumentos de entrada aos atributos da instância. self.nome = nome self.raca = raca self.idade = idade # 'idade' tem um valor padrão de 0 print(f\"Um novo cachorro chamado {self.nome} foi criado!\") def latir(self): return f\"{self.nome} diz: Au au!\" def exibir_info(self): return f\"{self.nome} é um {self.raca} de {self.idade} anos.\" # Criando instâncias de Cachorro (o __init__ é chamado automaticamente) cachorro1 = Cachorro(\"Buddy\", \"Golden Retriever\", 3) cachorro2 = Cachorro(\"Lucy\", \"Labrador\") # 'idade' usará o valor padrão (0) cachorro3 = Cachorro(\"Max\", \"Poodle\", 5) print(f\"\\nInfo do Cachorro 1: {cachorro1.exibir_info()}\") print(cachorro1.latir()) print(f\"Info do Cachorro 2: {cachorro2.exibir_info()}\") print(cachorro2.latir()) print(f\"Info do Cachorro 3: {cachorro3.exibir_info()}\") print(cachorro3.latir()) # Tentar criar um Cachorro sem os argumentos obrigatórios causaria um TypeError # cachorro_incompleto = Cachorro() # TypeError: __init__() missing 2 required positional arguments: 'nome' and 'raca' ``` Neste segundo exemplo, ao criar `cachorro1`, `cachorro2`, e `cachorro3`, o `__init__` é automaticamente invocado, garantindo que cada objeto tenha seus atributos `nome`, `raca` e `idade` definidos desde o momento da criação. Isso torna o código mais limpo, robusto e fácil de usar. Em resumo, `__init__` é a espinha dorsal para construir objetos bem formados e previsíveis em Python, estabelecendo a identidade e o estado inicial de cada instância de uma classe."


scorer = BERTScorer(model_type="bert-base-multilingual-cased")
P, R, F1 = scorer.score([canditate], [golden_answer])
print(f"BERTScore Precision: {P.mean():.4f}, Recall: {R.mean():.4f}, F1: {F1.mean():.4f}")